{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Projectile motion describes the trajectory of an object under the influence of gravity, assuming no other forces (e.g., air resistance) act upon it. Let\u2019s derive the governing equations from first principles. 1.1 Deriving the Equations of Motion The motion can be split into horizontal (x) and vertical (y) components. Assume the projectile is launched from the origin \\((x_0, y_0) = (0, 0)\\) with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) from the horizontal. The acceleration due to gravity is \\(g\\) , acting downward. Initial velocities: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Accelerations: Horizontal: \\(a_x = 0\\) (no horizontal forces) Vertical: \\(a_y = -g\\) Using Newton\u2019s equations of motion, the position as a function of time \\(t\\) is: Horizontal: \\(x(t) = v_{0x} t = (v_0 \\cos\\theta) t\\) Vertical: \\(y(t) = v_{0y} t + \\frac{1}{2} a_y t^2 = (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2\\) 1.2 Time of Flight The projectile returns to the ground when \\(y(t) = 0\\) : \\[ (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2 = 0 \\] Factorizing: \\[ t \\left( v_0 \\sin\\theta - \\frac{1}{2} g t \\right) = 0 \\] Solutions: \\(t = 0\\) (launch) or \\(t = \\frac{2 v_0 \\sin\\theta}{g}\\) (landing). Thus, the time of flight \\(T\\) is: \\[ T = \\frac{2 v_0 \\sin\\theta}{g} \\] 1.3 Range Equation The horizontal range \\(R\\) is the distance traveled when \\(t = T\\) : \\[ R = v_{0x} T = (v_0 \\cos\\theta) \\cdot \\frac{2 v_0 \\sin\\theta}{g} \\] Using the trigonometric identity \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] This is the range as a function of the angle of projection \\(\\theta\\) . 1.4 Family of Solutions The range depends on free parameters: \\(v_0\\) : Initial velocity \\(g\\) : Gravitational acceleration \\(\\theta\\) : Angle of projection Varying these parameters generates a family of solutions. For instance, increasing \\(v_0\\) scales \\(R\\) quadratically, while \\(g\\) inversely affects \\(R\\) . 2. Analysis of the Range 2.1 Dependence on Angle \\(\\theta\\) The term \\(\\sin 2\\theta\\) dictates the angular dependence: At \\(\\theta = 0^\\circ\\) or \\(90^\\circ\\) , \\(\\sin 2\\theta = 0\\) , so \\(R = 0\\) . Maximum range occurs when \\(\\sin 2\\theta = 1\\) , i.e., \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) : \\[ R_{\\text{max}} = \\frac{v_0^2}{g} \\] Complementary angles (e.g., \\(30^\\circ\\) and \\(60^\\circ\\) ) yield the same range since \\(\\sin(180^\\circ - 2\\theta) = \\sin 2\\theta\\) . 2.2 Influence of Parameters Initial Velocity ( \\(v_0\\) ) : \\(R \\propto v_0^2\\) . Doubling \\(v_0\\) quadruples the range. Gravity ( \\(g\\) ) : \\(R \\propto \\frac{1}{g}\\) . On the Moon ( \\(g \\approx 1.62 \\, \\text{m/s}^2\\) ), the range is ~6 times larger than on Earth ( \\(g \\approx 9.81 \\, \\text{m/s}^2\\) ). 3. Practical Applications 3.1 Uneven Terrain For a launch height \\(h\\) , the vertical displacement becomes: $$ y(t) = h + (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2 $$ Set \\(y(t) = 0\\) to find the new time of flight: \\[ \\frac{1}{2} g t^2 - (v_0 \\sin\\theta) t - h = 0 \\] Solve the quadratic equation for \\(t\\) , then compute \\(R = (v_0 \\cos\\theta) t\\) . Max Range = 49.78 m at 39.0\u00b0 3.2 Air Resistance With drag ( \\(F_d = -k v\\) ), the equations become nonlinear: \\[ m \\frac{dv_x}{dt} = -k v_x, \\quad m \\frac{dv_y}{dt} = -mg - k v_y \\] Analytical solutions are complex, so numerical methods (e.g., Euler or Runge-Kutta) are typically used. 3.3 Real-World Examples Sports : Optimizing a basketball shot ( \\(\\theta \\approx 45^\\circ\\) ). Engineering : Artillery trajectories with wind and drag. Astrophysics : Planetary motion with adjusted \\(g\\) . 4. Implementation Below is a Python script to simulate and visualize the range versus angle. v0 = 10 m/s, Max Range at 45\u00b0 = 10.19 m v0 = 20 m/s, Max Range at 45\u00b0 = 40.77 m v0 = 30 m/s, Max Range at 45\u00b0 = 91.74 m","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion describes the trajectory of an object under the influence of gravity, assuming no other forces (e.g., air resistance) act upon it. Let\u2019s derive the governing equations from first principles.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-deriving-the-equations-of-motion","text":"The motion can be split into horizontal (x) and vertical (y) components. Assume the projectile is launched from the origin \\((x_0, y_0) = (0, 0)\\) with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) from the horizontal. The acceleration due to gravity is \\(g\\) , acting downward. Initial velocities: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Accelerations: Horizontal: \\(a_x = 0\\) (no horizontal forces) Vertical: \\(a_y = -g\\) Using Newton\u2019s equations of motion, the position as a function of time \\(t\\) is: Horizontal: \\(x(t) = v_{0x} t = (v_0 \\cos\\theta) t\\) Vertical: \\(y(t) = v_{0y} t + \\frac{1}{2} a_y t^2 = (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2\\)","title":"1.1 Deriving the Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"The projectile returns to the ground when \\(y(t) = 0\\) : \\[ (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2 = 0 \\] Factorizing: \\[ t \\left( v_0 \\sin\\theta - \\frac{1}{2} g t \\right) = 0 \\] Solutions: \\(t = 0\\) (launch) or \\(t = \\frac{2 v_0 \\sin\\theta}{g}\\) (landing). Thus, the time of flight \\(T\\) is: \\[ T = \\frac{2 v_0 \\sin\\theta}{g} \\]","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-range-equation","text":"The horizontal range \\(R\\) is the distance traveled when \\(t = T\\) : \\[ R = v_{0x} T = (v_0 \\cos\\theta) \\cdot \\frac{2 v_0 \\sin\\theta}{g} \\] Using the trigonometric identity \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] This is the range as a function of the angle of projection \\(\\theta\\) .","title":"1.3 Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-family-of-solutions","text":"The range depends on free parameters: \\(v_0\\) : Initial velocity \\(g\\) : Gravitational acceleration \\(\\theta\\) : Angle of projection Varying these parameters generates a family of solutions. For instance, increasing \\(v_0\\) scales \\(R\\) quadratically, while \\(g\\) inversely affects \\(R\\) .","title":"1.4 Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-dependence-on-angle-theta","text":"The term \\(\\sin 2\\theta\\) dictates the angular dependence: At \\(\\theta = 0^\\circ\\) or \\(90^\\circ\\) , \\(\\sin 2\\theta = 0\\) , so \\(R = 0\\) . Maximum range occurs when \\(\\sin 2\\theta = 1\\) , i.e., \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) : \\[ R_{\\text{max}} = \\frac{v_0^2}{g} \\] Complementary angles (e.g., \\(30^\\circ\\) and \\(60^\\circ\\) ) yield the same range since \\(\\sin(180^\\circ - 2\\theta) = \\sin 2\\theta\\) .","title":"2.1 Dependence on Angle \\(\\theta\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-influence-of-parameters","text":"Initial Velocity ( \\(v_0\\) ) : \\(R \\propto v_0^2\\) . Doubling \\(v_0\\) quadruples the range. Gravity ( \\(g\\) ) : \\(R \\propto \\frac{1}{g}\\) . On the Moon ( \\(g \\approx 1.62 \\, \\text{m/s}^2\\) ), the range is ~6 times larger than on Earth ( \\(g \\approx 9.81 \\, \\text{m/s}^2\\) ).","title":"2.2 Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-uneven-terrain","text":"For a launch height \\(h\\) , the vertical displacement becomes: $$ y(t) = h + (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2 $$ Set \\(y(t) = 0\\) to find the new time of flight: \\[ \\frac{1}{2} g t^2 - (v_0 \\sin\\theta) t - h = 0 \\] Solve the quadratic equation for \\(t\\) , then compute \\(R = (v_0 \\cos\\theta) t\\) . Max Range = 49.78 m at 39.0\u00b0","title":"3.1 Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-air-resistance","text":"With drag ( \\(F_d = -k v\\) ), the equations become nonlinear: \\[ m \\frac{dv_x}{dt} = -k v_x, \\quad m \\frac{dv_y}{dt} = -mg - k v_y \\] Analytical solutions are complex, so numerical methods (e.g., Euler or Runge-Kutta) are typically used.","title":"3.2 Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-real-world-examples","text":"Sports : Optimizing a basketball shot ( \\(\\theta \\approx 45^\\circ\\) ). Engineering : Artillery trajectories with wind and drag. Astrophysics : Planetary motion with adjusted \\(g\\) .","title":"3.3 Real-World Examples"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Below is a Python script to simulate and visualize the range versus angle. v0 = 10 m/s, Max Range at 45\u00b0 = 10.19 m v0 = 20 m/s, Max Range at 45\u00b0 = 40.77 m v0 = 30 m/s, Max Range at 45\u00b0 = 91.74 m","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a fascinating system that evolves from simple harmonic motion to complex dynamics due to damping and periodic external forcing. This interplay introduces phenomena like resonance, chaos, and quasiperiodic motion, offering insights into real-world systems such as mechanical oscillators, climate models, and structural engineering under periodic loads. The addition of forcing parameters\u2014amplitude and frequency\u2014enriches the system\u2019s behavior, making it a powerful tool for studying both fundamental physics and practical applications. 1. Theoretical Foundation 1.1 Governing Differential Equation The motion of a pendulum with length \\(l\\) , mass \\(m\\) , under gravitational acceleration \\(g\\) , damping coefficient \\(b\\) , and external forcing \\(F(t) = F_0 \\cos(\\omega t)\\) is governed by: \\[ \\frac{d^2\\theta}{dt^2} + \\frac{b}{m} \\frac{d\\theta}{dt} + \\frac{g}{l} \\sin\\theta = \\frac{F_0}{ml} \\cos(\\omega t) \\] where \\(\\theta\\) is the angular displacement, \\(\\frac{b}{m}\\) is the damping rate, \\(\\frac{g}{l}\\) relates to the natural frequency, and \\(\\frac{F_0}{ml} \\cos(\\omega t)\\) is the driving term. Define: Natural angular frequency: \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) Damping constant: \\(\\gamma = \\frac{b}{m}\\) Driving amplitude: \\(A = \\frac{F_0}{ml}\\) Thus, the equation becomes: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] 1.2 Small-Angle Approximation For small \\(\\theta\\) , \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to a linear forced damped oscillator: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a second-order linear differential equation. The homogeneous solution is: \\[ \\theta_h(t) = e^{-\\frac{\\gamma}{2} t} \\left( C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t) \\right) \\] where \\(\\omega_d = \\sqrt{\\omega_0^2 - \\left(\\frac{\\gamma}{2}\\right)^2}\\) is the damped frequency, and \\(C_1, C_2\\) depend on initial conditions. The particular solution for the driving term is: \\[ \\theta_p(t) = B \\cos(\\omega t - \\phi) \\] where the amplitude \\(B\\) and phase \\(\\phi\\) are: \\[ B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\gamma \\omega)^2}}, \\quad \\tan\\phi = \\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2} \\] 1.3 Resonance Resonance occurs when the driving frequency \\(\\omega\\) approaches the natural frequency \\(\\omega_0\\) . For low damping ( \\(\\gamma \\ll \\omega_0\\) ), the amplitude peaks near \\(\\omega = \\omega_0\\) , with maximum: \\[ B_{\\text{max}} \\approx \\frac{A}{\\gamma \\omega_0} \\] This amplification highlights energy transfer efficiency. 2. Analysis of Dynamics 2.1 Parameter Influence Damping ( \\(\\gamma\\) ) : Low \\(\\gamma\\) sustains oscillations; high \\(\\gamma\\) causes rapid decay. Driving Amplitude ( \\(A\\) ) : Higher \\(A\\) can push the system into nonlinear regimes or chaos. Driving Frequency ( \\(\\omega\\) ) : Near \\(\\omega_0\\) , resonance amplifies motion; far from \\(\\omega_0\\) , motion may become quasiperiodic or chaotic. 2.2 Transition to Chaos For large \\(A\\) or specific \\(\\omega\\) , the nonlinear term \\(\\sin\\theta\\) dominates, leading to chaotic behavior. This is characterized by sensitivity to initial conditions and aperiodic motion, observable in phase portraits and Poincar\u00e9 sections. 3. Practical Applications Energy Harvesting : Pendulum-based devices convert ambient vibrations into electrical energy. Suspension Bridges : Model swaying under wind (e.g., Tacoma Narrows). Oscillating Circuits : Analogous to driven RLC circuits in electronics. 4. Implementation 4.1 Python Code 1: Small-Angle Resonance Simulation Simulates the linear approximation and plots amplitude vs. time. 4.2 Python Code 2: Nonlinear Simulation with Phase Portrait Solves the full nonlinear equation and plots the phase portrait. 4.3 Python Code 3: Poincar\u00e9 Section and Chaos Visualizes the Poincar\u00e9 section to detect chaotic behavior.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a fascinating system that evolves from simple harmonic motion to complex dynamics due to damping and periodic external forcing. This interplay introduces phenomena like resonance, chaos, and quasiperiodic motion, offering insights into real-world systems such as mechanical oscillators, climate models, and structural engineering under periodic loads. The addition of forcing parameters\u2014amplitude and frequency\u2014enriches the system\u2019s behavior, making it a powerful tool for studying both fundamental physics and practical applications.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-governing-differential-equation","text":"The motion of a pendulum with length \\(l\\) , mass \\(m\\) , under gravitational acceleration \\(g\\) , damping coefficient \\(b\\) , and external forcing \\(F(t) = F_0 \\cos(\\omega t)\\) is governed by: \\[ \\frac{d^2\\theta}{dt^2} + \\frac{b}{m} \\frac{d\\theta}{dt} + \\frac{g}{l} \\sin\\theta = \\frac{F_0}{ml} \\cos(\\omega t) \\] where \\(\\theta\\) is the angular displacement, \\(\\frac{b}{m}\\) is the damping rate, \\(\\frac{g}{l}\\) relates to the natural frequency, and \\(\\frac{F_0}{ml} \\cos(\\omega t)\\) is the driving term. Define: Natural angular frequency: \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) Damping constant: \\(\\gamma = \\frac{b}{m}\\) Driving amplitude: \\(A = \\frac{F_0}{ml}\\) Thus, the equation becomes: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\]","title":"1.1 Governing Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-small-angle-approximation","text":"For small \\(\\theta\\) , \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to a linear forced damped oscillator: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a second-order linear differential equation. The homogeneous solution is: \\[ \\theta_h(t) = e^{-\\frac{\\gamma}{2} t} \\left( C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t) \\right) \\] where \\(\\omega_d = \\sqrt{\\omega_0^2 - \\left(\\frac{\\gamma}{2}\\right)^2}\\) is the damped frequency, and \\(C_1, C_2\\) depend on initial conditions. The particular solution for the driving term is: \\[ \\theta_p(t) = B \\cos(\\omega t - \\phi) \\] where the amplitude \\(B\\) and phase \\(\\phi\\) are: \\[ B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\gamma \\omega)^2}}, \\quad \\tan\\phi = \\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2} \\]","title":"1.2 Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#13-resonance","text":"Resonance occurs when the driving frequency \\(\\omega\\) approaches the natural frequency \\(\\omega_0\\) . For low damping ( \\(\\gamma \\ll \\omega_0\\) ), the amplitude peaks near \\(\\omega = \\omega_0\\) , with maximum: \\[ B_{\\text{max}} \\approx \\frac{A}{\\gamma \\omega_0} \\] This amplification highlights energy transfer efficiency.","title":"1.3 Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-parameter-influence","text":"Damping ( \\(\\gamma\\) ) : Low \\(\\gamma\\) sustains oscillations; high \\(\\gamma\\) causes rapid decay. Driving Amplitude ( \\(A\\) ) : Higher \\(A\\) can push the system into nonlinear regimes or chaos. Driving Frequency ( \\(\\omega\\) ) : Near \\(\\omega_0\\) , resonance amplifies motion; far from \\(\\omega_0\\) , motion may become quasiperiodic or chaotic.","title":"2.1 Parameter Influence"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-transition-to-chaos","text":"For large \\(A\\) or specific \\(\\omega\\) , the nonlinear term \\(\\sin\\theta\\) dominates, leading to chaotic behavior. This is characterized by sensitivity to initial conditions and aperiodic motion, observable in phase portraits and Poincar\u00e9 sections.","title":"2.2 Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Pendulum-based devices convert ambient vibrations into electrical energy. Suspension Bridges : Model swaying under wind (e.g., Tacoma Narrows). Oscillating Circuits : Analogous to driven RLC circuits in electronics.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-python-code-1-small-angle-resonance-simulation","text":"Simulates the linear approximation and plots amplitude vs. time.","title":"4.1 Python Code 1: Small-Angle Resonance Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-python-code-2-nonlinear-simulation-with-phase-portrait","text":"Solves the full nonlinear equation and plots the phase portrait.","title":"4.2 Python Code 2: Nonlinear Simulation with Phase Portrait"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#43-python-code-3-poincare-section-and-chaos","text":"Visualizes the Poincar\u00e9 section to detect chaotic behavior.","title":"4.3 Python Code 3: Poincar\u00e9 Section and Chaos"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius: Kepler's Third Law Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This law allows for the determination of planetary motions and has broad implications for understanding gravitational interactions both on local and cosmic scales. By analyzing this relationship, we can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems. Task Overview The task involves deriving the relationship between the square of the orbital period and the cube of the orbital radius for circular orbits. We will explore the implications of this law in astronomy, investigate real-world examples, and implement a computational model to simulate circular orbits and verify this relationship. 1. Derivation of Kepler\u2019s Third Law For a body in a circular orbit, the centripetal force required to keep the body moving in orbit is provided by the gravitational force. This is expressed as: \\[ F_{\\text{centripetal}} = F_{\\text{gravitational}} \\] The centripetal force is given by: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] where: \\(m\\) is the mass of the orbiting body, \\(v\\) is the orbital velocity, \\(r\\) is the orbital radius. The gravitational force is: \\[ F_{\\text{gravitational}} = \\frac{G M m}{r^2} \\] where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the central body (e.g., the Sun), \\(r\\) is the orbital radius. By equating the two forces: \\[ \\frac{m v^2}{r} = \\frac{G M m}{r^2} \\] Simplifying: \\[ v^2 = \\frac{G M}{r} \\] Now, the velocity is related to the orbital period \\(T\\) by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the above equation: \\[ \\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r} \\] Simplifying further: \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Now, solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] This is the relationship between the orbital period squared ( \\(T^2\\) ) and the orbital radius cubed ( \\(r^3\\) ), which is Kepler's Third Law: \\[ T^2 \\propto r^3 \\] 2. Implications of Kepler's Third Law Kepler\u2019s Third Law provides several important insights into the motion of celestial bodies: Planetary Masses : By measuring the orbital period and radius of a satellite or planet, the mass of the central body (e.g., the Sun or Earth) can be determined. Orbital Distances : The law helps calculate the distance of a planet or moon from the central star or planet based on its orbital period. Satellite Orbits : Kepler\u2019s Third Law is used extensively in satellite communication and space exploration, determining satellite orbital periods for given altitudes. Real-World Example: The Moon\u2019s Orbit Around Earth The Moon orbits Earth at an average distance of \\(r = 3.84 \\times 10^8\\) meters and has an orbital period of approximately \\(T = 27.3\\) days. Using Kepler's Third Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] Substituting the values for \\(r\\) and \\(M\\) (the mass of Earth): \\[ T = \\sqrt{\\frac{4\\pi^2 (3.84 \\times 10^8)^3}{(6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}} \\] This confirms that Kepler's Third Law can be used to accurately predict the Moon's orbital period. 3. Computational Model to Simulate Circular Orbits Below is a Python script to simulate the motion of a planet in a circular orbit using Newtonian mechanics. This simulation will help visualize the orbital motion and verify Kepler's Third Law. Code 1: Simulating a Circular Orbit Using Numerical Integration 4. Testing Kepler\u2019s Third Law We can now test the proportionality \\(T^2 \\propto r^3\\) numerically. 5. Extension to Elliptical Orbits For elliptical orbits, Kepler\u2019s Third Law still holds, but we replace the orbital radius \\(r\\) with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} a^3 \\] This is the general form of Kepler\u2019s Third Law for elliptical orbits, and it allows us to calculate the orbital period of objects in elliptical orbits, such as the planets in the Solar System. Code 3: Simulating an Elliptical Orbit","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-keplers-third-law","text":"","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This law allows for the determination of planetary motions and has broad implications for understanding gravitational interactions both on local and cosmic scales. By analyzing this relationship, we can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-overview","text":"The task involves deriving the relationship between the square of the orbital period and the cube of the orbital radius for circular orbits. We will explore the implications of this law in astronomy, investigate real-world examples, and implement a computational model to simulate circular orbits and verify this relationship.","title":"Task Overview"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-keplers-third-law","text":"For a body in a circular orbit, the centripetal force required to keep the body moving in orbit is provided by the gravitational force. This is expressed as: \\[ F_{\\text{centripetal}} = F_{\\text{gravitational}} \\] The centripetal force is given by: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] where: \\(m\\) is the mass of the orbiting body, \\(v\\) is the orbital velocity, \\(r\\) is the orbital radius. The gravitational force is: \\[ F_{\\text{gravitational}} = \\frac{G M m}{r^2} \\] where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the central body (e.g., the Sun), \\(r\\) is the orbital radius. By equating the two forces: \\[ \\frac{m v^2}{r} = \\frac{G M m}{r^2} \\] Simplifying: \\[ v^2 = \\frac{G M}{r} \\] Now, the velocity is related to the orbital period \\(T\\) by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the above equation: \\[ \\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r} \\] Simplifying further: \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Now, solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] This is the relationship between the orbital period squared ( \\(T^2\\) ) and the orbital radius cubed ( \\(r^3\\) ), which is Kepler's Third Law: \\[ T^2 \\propto r^3 \\]","title":"1. Derivation of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-of-keplers-third-law","text":"Kepler\u2019s Third Law provides several important insights into the motion of celestial bodies: Planetary Masses : By measuring the orbital period and radius of a satellite or planet, the mass of the central body (e.g., the Sun or Earth) can be determined. Orbital Distances : The law helps calculate the distance of a planet or moon from the central star or planet based on its orbital period. Satellite Orbits : Kepler\u2019s Third Law is used extensively in satellite communication and space exploration, determining satellite orbital periods for given altitudes.","title":"2. Implications of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-example-the-moons-orbit-around-earth","text":"The Moon orbits Earth at an average distance of \\(r = 3.84 \\times 10^8\\) meters and has an orbital period of approximately \\(T = 27.3\\) days. Using Kepler's Third Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] Substituting the values for \\(r\\) and \\(M\\) (the mass of Earth): \\[ T = \\sqrt{\\frac{4\\pi^2 (3.84 \\times 10^8)^3}{(6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}} \\] This confirms that Kepler's Third Law can be used to accurately predict the Moon's orbital period.","title":"Real-World Example: The Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-computational-model-to-simulate-circular-orbits","text":"Below is a Python script to simulate the motion of a planet in a circular orbit using Newtonian mechanics. This simulation will help visualize the orbital motion and verify Kepler's Third Law.","title":"3. Computational Model to Simulate Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#code-1-simulating-a-circular-orbit-using-numerical-integration","text":"","title":"Code 1: Simulating a Circular Orbit Using Numerical Integration"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-testing-keplers-third-law","text":"We can now test the proportionality \\(T^2 \\propto r^3\\) numerically.","title":"4. Testing Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extension-to-elliptical-orbits","text":"For elliptical orbits, Kepler\u2019s Third Law still holds, but we replace the orbital radius \\(r\\) with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} a^3 \\] This is the general form of Kepler\u2019s Third Law for elliptical orbits, and it allows us to calculate the orbital period of objects in elliptical orbits, such as the planets in the Solar System.","title":"5. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#code-3-simulating-an-elliptical-orbit","text":"","title":"Code 3: Simulating an Elliptical Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is fundamental to understanding how objects can break free from a celestial body's gravitational pull. Building on this, the first, second, and third cosmic velocities provide critical thresholds for orbiting a planet, escaping its gravity, and departing its star system, respectively. These velocities are essential for space exploration, governing satellite launches, interplanetary missions, and the theoretical framework for interstellar travel. Definitions and Physical Meaning First Cosmic Velocity ( \\(v_1\\) ) : The minimum speed required for an object to achieve a stable circular orbit around a celestial body at its surface. It is essentially the orbital velocity at radius \\(r = R\\) , where \\(R\\) is the body's radius. Second Cosmic Velocity ( \\(v_2\\) ) : Known as the escape velocity, this is the minimum speed needed to escape a celestial body\u2019s gravitational field from its surface, reaching infinity with zero residual velocity. Third Cosmic Velocity ( \\(v_3\\) ) : The minimum speed required to escape the gravitational influence of a star system (e.g., the Solar System) from a planet\u2019s surface, assuming the planet is in a circular orbit around the star. Mathematical Derivations First Cosmic Velocity ( \\(v_1\\) ) The first cosmic velocity is derived from the condition for circular orbit, where gravitational force equals centripetal force: \\(G M m / r^2 = m v^2 / r\\) . At the surface, \\(r = R\\) : \\[ G M / R^2 = v_1^2 / R \\] Multiply by \\(R\\) : \\[ v_1^2 = G M / R \\] Thus: \\[ v_1 = \\sqrt{G M / R} \\] where \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, and \\(R\\) is its radius. Second Cosmic Velocity ( \\(v_2\\) ) The escape velocity is derived from conservation of energy. Total mechanical energy at the surface (kinetic + potential) must be zero at infinity: \\[ \\frac{1}{2} m v_2^2 - G M m / R = 0 \\] Simplify: \\[ \\frac{1}{2} v_2^2 = G M / R \\] \\[ v_2^2 = 2 G M / R \\] Thus: \\[ v_2 = \\sqrt{2 G M / R} \\] Note that \\(v_2 = \\sqrt{2} v_1\\) , meaning escape velocity is \\(\\sqrt{2}\\) times the orbital velocity. Third Cosmic Velocity ( \\(v_3\\) ) The third cosmic velocity is more complex, as it involves escaping the star\u2019s gravitational field from a planet\u2019s surface. For a planet in a circular orbit around a star (mass \\(M_s\\) , orbital radius \\(a\\) ), the planet\u2019s orbital velocity is \\(v_p = \\sqrt{G M_s / a}\\) . The total velocity to escape the Solar System from the planet\u2019s surface combines: Escaping the planet: \\(v_2 = \\sqrt{2 G M / R}\\) . Matching the planet\u2019s orbital velocity and exceeding the star\u2019s escape velocity at \\(a\\) . The escape velocity from the star\u2019s field at distance \\(a\\) is: \\[ v_{\\text{esc, star}} = \\sqrt{2 G M_s / a} \\] Assuming the launch is in the direction of the planet\u2019s orbit, the approximate \\(v_3\\) from the surface is: \\[ v_3 \\approx \\sqrt{v_2^2 + (v_{\\text{esc, star}} - v_p)^2} \\] For Earth escaping the Sun: \\[ v_3 \\approx \\sqrt{(11.2)^2 + (42.1 - 29.8)^2} \\, \\text{km/s} \\] Parameters Affecting These Velocities Mass ( \\(M\\) ) : Higher mass increases all velocities ( \\(v_1\\) , \\(v_2\\) , \\(v_3\\) ). Radius ( \\(R\\) ) : Larger radius decreases \\(v_1\\) and \\(v_2\\) (inverse relationship). Star\u2019s Mass ( \\(M_s\\) ) and Orbital Distance ( \\(a\\) ) : For \\(v_3\\) , a more massive star or smaller orbit increases the velocity needed to escape the system. Calculations for Celestial Bodies Earth \\(M = 5.972 \\times 10^{24}\\) kg \\(R = 6.371 \\times 10^6\\) m \\(G = 6.6743 \\times 10^{-11}\\) m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 \\(M_s = 1.989 \\times 10^{30}\\) kg (Sun\u2019s mass) \\(a = 1.496 \\times 10^{11}\\) m (1 AU) \\[ v_1 = \\sqrt{G M / R} = \\sqrt{(6.6743 \\times 10^{-11}) (5.972 \\times 10^{24}) / (6.371 \\times 10^6)} \\approx 7.91 \\, \\text{km/s} \\] \\[ v_2 = \\sqrt{2 G M / R} = \\sqrt{2} \\cdot 7.91 \\approx 11.19 \\, \\text{km/s} \\] \\[ v_3 \\approx \\sqrt{(11.19)^2 + (42.1 - 29.8)^2} \\approx 16.6 \\, \\text{km/s} \\] Mars \\(M = 6.417 \\times 10^{23}\\) kg \\(R = 3.39 \\times 10^6\\) m \\[ v_1 = \\sqrt{(6.6743 \\times 10^{-11}) (6.417 \\times 10^{23}) / (3.39 \\times 10^6)} \\approx 3.55 \\, \\text{km/s} \\] \\[ v_2 = \\sqrt{2} \\cdot 3.55 \\approx 5.02 \\, \\text{km/s} \\] Jupiter \\(M = 1.899 \\times 10^{27}\\) kg \\(R = 6.991 \\times 10^7\\) m \\[ v_1 = \\sqrt{(6.6743 \\times 10^{-11}) (1.899 \\times 10^{27}) / (6.991 \\times 10^7)} \\approx 42.6 \\, \\text{km/s} \\] \\[ v_2 = \\sqrt{2} \\cdot 42.6 \\approx 60.2 \\, \\text{km/s} \\] Importance in Space Exploration Launching Satellites : \\(v_1\\) determines the speed for low Earth orbit (e.g., 7.91 km/s). Rockets must exceed this, typically reaching 8-10 km/s with altitude. Interplanetary Missions : \\(v_2\\) (11.19 km/s for Earth) is the threshold for missions to Mars or the Moon. Additional velocity from Earth\u2019s motion aids efficiency. Interstellar Travel : \\(v_3\\) (16.6 km/s from Earth) sets the bar for escaping the Solar System, as achieved by Voyager 1 using gravitational assists. Python Scripts and Visualizations Python Script 1: Cosmic Velocities Bar Plot Python Script 2: Velocity vs. Mass/Radius Ratio","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is fundamental to understanding how objects can break free from a celestial body's gravitational pull. Building on this, the first, second, and third cosmic velocities provide critical thresholds for orbiting a planet, escaping its gravity, and departing its star system, respectively. These velocities are essential for space exploration, governing satellite launches, interplanetary missions, and the theoretical framework for interstellar travel.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-and-physical-meaning","text":"First Cosmic Velocity ( \\(v_1\\) ) : The minimum speed required for an object to achieve a stable circular orbit around a celestial body at its surface. It is essentially the orbital velocity at radius \\(r = R\\) , where \\(R\\) is the body's radius. Second Cosmic Velocity ( \\(v_2\\) ) : Known as the escape velocity, this is the minimum speed needed to escape a celestial body\u2019s gravitational field from its surface, reaching infinity with zero residual velocity. Third Cosmic Velocity ( \\(v_3\\) ) : The minimum speed required to escape the gravitational influence of a star system (e.g., the Solar System) from a planet\u2019s surface, assuming the planet is in a circular orbit around the star.","title":"Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"","title":"Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"The first cosmic velocity is derived from the condition for circular orbit, where gravitational force equals centripetal force: \\(G M m / r^2 = m v^2 / r\\) . At the surface, \\(r = R\\) : \\[ G M / R^2 = v_1^2 / R \\] Multiply by \\(R\\) : \\[ v_1^2 = G M / R \\] Thus: \\[ v_1 = \\sqrt{G M / R} \\] where \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, and \\(R\\) is its radius.","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"The escape velocity is derived from conservation of energy. Total mechanical energy at the surface (kinetic + potential) must be zero at infinity: \\[ \\frac{1}{2} m v_2^2 - G M m / R = 0 \\] Simplify: \\[ \\frac{1}{2} v_2^2 = G M / R \\] \\[ v_2^2 = 2 G M / R \\] Thus: \\[ v_2 = \\sqrt{2 G M / R} \\] Note that \\(v_2 = \\sqrt{2} v_1\\) , meaning escape velocity is \\(\\sqrt{2}\\) times the orbital velocity.","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"The third cosmic velocity is more complex, as it involves escaping the star\u2019s gravitational field from a planet\u2019s surface. For a planet in a circular orbit around a star (mass \\(M_s\\) , orbital radius \\(a\\) ), the planet\u2019s orbital velocity is \\(v_p = \\sqrt{G M_s / a}\\) . The total velocity to escape the Solar System from the planet\u2019s surface combines: Escaping the planet: \\(v_2 = \\sqrt{2 G M / R}\\) . Matching the planet\u2019s orbital velocity and exceeding the star\u2019s escape velocity at \\(a\\) . The escape velocity from the star\u2019s field at distance \\(a\\) is: \\[ v_{\\text{esc, star}} = \\sqrt{2 G M_s / a} \\] Assuming the launch is in the direction of the planet\u2019s orbit, the approximate \\(v_3\\) from the surface is: \\[ v_3 \\approx \\sqrt{v_2^2 + (v_{\\text{esc, star}} - v_p)^2} \\] For Earth escaping the Sun: \\[ v_3 \\approx \\sqrt{(11.2)^2 + (42.1 - 29.8)^2} \\, \\text{km/s} \\]","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-affecting-these-velocities","text":"Mass ( \\(M\\) ) : Higher mass increases all velocities ( \\(v_1\\) , \\(v_2\\) , \\(v_3\\) ). Radius ( \\(R\\) ) : Larger radius decreases \\(v_1\\) and \\(v_2\\) (inverse relationship). Star\u2019s Mass ( \\(M_s\\) ) and Orbital Distance ( \\(a\\) ) : For \\(v_3\\) , a more massive star or smaller orbit increases the velocity needed to escape the system.","title":"Parameters Affecting These Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculations-for-celestial-bodies","text":"","title":"Calculations for Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth","text":"\\(M = 5.972 \\times 10^{24}\\) kg \\(R = 6.371 \\times 10^6\\) m \\(G = 6.6743 \\times 10^{-11}\\) m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 \\(M_s = 1.989 \\times 10^{30}\\) kg (Sun\u2019s mass) \\(a = 1.496 \\times 10^{11}\\) m (1 AU) \\[ v_1 = \\sqrt{G M / R} = \\sqrt{(6.6743 \\times 10^{-11}) (5.972 \\times 10^{24}) / (6.371 \\times 10^6)} \\approx 7.91 \\, \\text{km/s} \\] \\[ v_2 = \\sqrt{2 G M / R} = \\sqrt{2} \\cdot 7.91 \\approx 11.19 \\, \\text{km/s} \\] \\[ v_3 \\approx \\sqrt{(11.19)^2 + (42.1 - 29.8)^2} \\approx 16.6 \\, \\text{km/s} \\]","title":"Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mars","text":"\\(M = 6.417 \\times 10^{23}\\) kg \\(R = 3.39 \\times 10^6\\) m \\[ v_1 = \\sqrt{(6.6743 \\times 10^{-11}) (6.417 \\times 10^{23}) / (3.39 \\times 10^6)} \\approx 3.55 \\, \\text{km/s} \\] \\[ v_2 = \\sqrt{2} \\cdot 3.55 \\approx 5.02 \\, \\text{km/s} \\]","title":"Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#jupiter","text":"\\(M = 1.899 \\times 10^{27}\\) kg \\(R = 6.991 \\times 10^7\\) m \\[ v_1 = \\sqrt{(6.6743 \\times 10^{-11}) (1.899 \\times 10^{27}) / (6.991 \\times 10^7)} \\approx 42.6 \\, \\text{km/s} \\] \\[ v_2 = \\sqrt{2} \\cdot 42.6 \\approx 60.2 \\, \\text{km/s} \\]","title":"Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"Launching Satellites : \\(v_1\\) determines the speed for low Earth orbit (e.g., 7.91 km/s). Rockets must exceed this, typically reaching 8-10 km/s with altitude. Interplanetary Missions : \\(v_2\\) (11.19 km/s for Earth) is the threshold for missions to Mars or the Moon. Additional velocity from Earth\u2019s motion aids efficiency. Interstellar Travel : \\(v_3\\) (16.6 km/s from Earth) sets the bar for escaping the Solar System, as achieved by Voyager 1 using gravitational assists.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-scripts-and-visualizations","text":"","title":"Python Scripts and Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-script-1-cosmic-velocities-bar-plot","text":"","title":"Python Script 1: Cosmic Velocities Bar Plot"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-script-2-velocity-vs-massradius-ratio","text":"","title":"Python Script 2: Velocity vs. Mass/Radius Ratio"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a moving rocket near Earth, its subsequent trajectory is determined by its initial position, velocity, and Earth\u2019s gravitational field. This scenario integrates orbital mechanics and numerical simulation, offering insights into payload deployment, orbital insertion, and reentry dynamics. Understanding these trajectories is critical for space mission planning, such as satellite launches or spacecraft reentry. Possible Trajectories The trajectory of a freely released payload depends on its specific energy and angular momentum relative to Earth. Using gravitational principles, the possible paths are: Elliptical Trajectory : If the payload\u2019s total mechanical energy \\(E < 0\\) , it follows a bound, elliptical orbit around Earth. Parabolic Trajectory : If \\(E = 0\\) , the payload escapes Earth with zero velocity at infinity, tracing a parabola. Hyperbolic Trajectory : If \\(E > 0\\) , the payload escapes with excess velocity, following a hyperbola. The specific energy per unit mass is: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{G M}{r} \\] where \\(v\\) is the initial velocity, \\(r\\) is the radial distance from Earth\u2019s center, \\(G\\) is the gravitational constant, and \\(M\\) is Earth\u2019s mass. The trajectory type is determined by: \\(\\epsilon < 0\\) : Elliptical \\(\\epsilon = 0\\) : Parabolic \\(\\epsilon > 0\\) : Hyperbolic Mathematical Derivation Equations of Motion Newton\u2019s Law of Gravitation provides the force: \\(F = G M m / r^2\\) . For a payload of mass \\(m\\) , the acceleration in polar coordinates (radial \\(r\\) , angular \\(\\theta\\) ) is: \\[ \\ddot{r} - r \\dot{\\theta}^2 = -\\frac{G M}{r^2} \\] \\[ r \\ddot{\\theta} + 2 \\dot{r} \\dot{\\theta} = 0 \\] The second equation implies conservation of angular momentum: \\(h = r^2 \\dot{\\theta} = \\text{constant}\\) . Trajectory Classification The orbit\u2019s shape is governed by the eccentricity \\(e\\) , derived from initial conditions: \\[ e = \\sqrt{1 + \\frac{2 \\epsilon h^2}{(G M)^2}} \\] \\(e < 1\\) : Elliptical \\(e = 1\\) : Parabolic \\(e > 1\\) : Hyperbolic For a circular orbit, \\(v = \\sqrt{G M / r}\\) , and for escape, \\(v = \\sqrt{2 G M / r}\\) . Numerical Analysis To compute the trajectory, we solve the differential equations numerically using initial conditions: position \\((r_0, \\theta_0)\\) and velocity \\((v_{r0}, v_{\\theta0})\\) . The state vector is \\([r, \\dot{r}, \\theta, \\dot{\\theta}]\\) , and we use a numerical integrator (e.g., Runge-Kutta) to simulate the path under Earth\u2019s gravity. Initial Conditions Example Altitude: 400 km ( \\(r_0 = 6.371 \\times 10^6 + 4 \\times 10^5 = 6.771 \\times 10^6\\) m) Earth\u2019s mass: \\(M = 5.972 \\times 10^{24}\\) kg \\(G = 6.6743 \\times 10^{-11}\\) m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 Circular velocity: \\(v_{\\theta0} = \\sqrt{G M / r_0} \\approx 7.67\\) km/s Test cases: \\(v = 0.8 v_c\\) , \\(v_c\\) , \\(1.5 v_c\\) (suborbital, orbital, escape) Relation to Space Scenarios Orbital Insertion : If \\(v \\approx v_c\\) , the payload enters an elliptical or circular orbit, useful for satellite deployment. Reentry : If \\(v < v_c\\) , the trajectory intersects Earth\u2019s surface or atmosphere, simulating a return path. Escape : If \\(v > \\sqrt{2 G M / r}\\) , the payload escapes Earth\u2019s gravity, relevant for interplanetary missions. Python Scripts and Visualizations Python Script 1: Trajectory Simulation Python Script 2: Energy-Based Trajectory Types","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, its subsequent trajectory is determined by its initial position, velocity, and Earth\u2019s gravitational field. This scenario integrates orbital mechanics and numerical simulation, offering insights into payload deployment, orbital insertion, and reentry dynamics. Understanding these trajectories is critical for space mission planning, such as satellite launches or spacecraft reentry.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#possible-trajectories","text":"The trajectory of a freely released payload depends on its specific energy and angular momentum relative to Earth. Using gravitational principles, the possible paths are: Elliptical Trajectory : If the payload\u2019s total mechanical energy \\(E < 0\\) , it follows a bound, elliptical orbit around Earth. Parabolic Trajectory : If \\(E = 0\\) , the payload escapes Earth with zero velocity at infinity, tracing a parabola. Hyperbolic Trajectory : If \\(E > 0\\) , the payload escapes with excess velocity, following a hyperbola. The specific energy per unit mass is: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{G M}{r} \\] where \\(v\\) is the initial velocity, \\(r\\) is the radial distance from Earth\u2019s center, \\(G\\) is the gravitational constant, and \\(M\\) is Earth\u2019s mass. The trajectory type is determined by: \\(\\epsilon < 0\\) : Elliptical \\(\\epsilon = 0\\) : Parabolic \\(\\epsilon > 0\\) : Hyperbolic","title":"Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#mathematical-derivation","text":"","title":"Mathematical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","text":"Newton\u2019s Law of Gravitation provides the force: \\(F = G M m / r^2\\) . For a payload of mass \\(m\\) , the acceleration in polar coordinates (radial \\(r\\) , angular \\(\\theta\\) ) is: \\[ \\ddot{r} - r \\dot{\\theta}^2 = -\\frac{G M}{r^2} \\] \\[ r \\ddot{\\theta} + 2 \\dot{r} \\dot{\\theta} = 0 \\] The second equation implies conservation of angular momentum: \\(h = r^2 \\dot{\\theta} = \\text{constant}\\) .","title":"Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-classification","text":"The orbit\u2019s shape is governed by the eccentricity \\(e\\) , derived from initial conditions: \\[ e = \\sqrt{1 + \\frac{2 \\epsilon h^2}{(G M)^2}} \\] \\(e < 1\\) : Elliptical \\(e = 1\\) : Parabolic \\(e > 1\\) : Hyperbolic For a circular orbit, \\(v = \\sqrt{G M / r}\\) , and for escape, \\(v = \\sqrt{2 G M / r}\\) .","title":"Trajectory Classification"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-analysis","text":"To compute the trajectory, we solve the differential equations numerically using initial conditions: position \\((r_0, \\theta_0)\\) and velocity \\((v_{r0}, v_{\\theta0})\\) . The state vector is \\([r, \\dot{r}, \\theta, \\dot{\\theta}]\\) , and we use a numerical integrator (e.g., Runge-Kutta) to simulate the path under Earth\u2019s gravity.","title":"Numerical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions-example","text":"Altitude: 400 km ( \\(r_0 = 6.371 \\times 10^6 + 4 \\times 10^5 = 6.771 \\times 10^6\\) m) Earth\u2019s mass: \\(M = 5.972 \\times 10^{24}\\) kg \\(G = 6.6743 \\times 10^{-11}\\) m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 Circular velocity: \\(v_{\\theta0} = \\sqrt{G M / r_0} \\approx 7.67\\) km/s Test cases: \\(v = 0.8 v_c\\) , \\(v_c\\) , \\(1.5 v_c\\) (suborbital, orbital, escape)","title":"Initial Conditions Example"},{"location":"1%20Physics/2%20Gravity/Problem_3/#relation-to-space-scenarios","text":"Orbital Insertion : If \\(v \\approx v_c\\) , the payload enters an elliptical or circular orbit, useful for satellite deployment. Reentry : If \\(v < v_c\\) , the trajectory intersects Earth\u2019s surface or atmosphere, simulating a return path. Escape : If \\(v > \\sqrt{2 G M / r}\\) , the payload escapes Earth\u2019s gravity, relevant for interplanetary missions.","title":"Relation to Space Scenarios"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-scripts-and-visualizations","text":"","title":"Python Scripts and Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-script-1-trajectory-simulation","text":"","title":"Python Script 1: Trajectory Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-script-2-energy-based-trajectory-types","text":"","title":"Python Script 2: Energy-Based Trajectory Types"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Interference Patterns of Waves on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns on a water surface. Ripples from multiple points form distinctive interference patterns, demonstrating how waves can reinforce (constructive interference) or cancel (destructive interference) each other. This phenomenon provides a visual way to study wave behavior, phase relationships, and the effects of multiple sources. Understanding these patterns is fundamental to wave physics, with applications in acoustics, optics, and fluid dynamics. Problem Statement The task is to analyze the interference patterns formed on a water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. A single wave from a source at \\((x_0, y_0)\\) is described by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] where: \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) , \\(A\\) is the amplitude, \\(k = 2\\pi / \\lambda\\) is the wave number, with wavelength \\(\\lambda\\) , \\(\\omega = 2\\pi f\\) is the angular frequency, with frequency \\(f\\) , \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source to \\((x, y)\\) , \\(\\phi\\) is the initial phase. The total displacement from \\(N\\) sources (vertices of the polygon) is given by the principle of superposition: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\eta_i(x, y, t) \\] We assume all sources emit waves with the same \\(A\\) , \\(\\lambda\\) , \\(f\\) , and a constant phase difference (set \\(\\phi = 0\\) for simplicity). Step-by-Step Analysis 1. Select a Regular Polygon Let\u2019s choose an equilateral triangle as the regular polygon, with vertices at \\((x_i, y_i)\\) for \\(i = 1, 2, 3\\) . Place the triangle centered at the origin with side length \\(s = 2\\) m: Vertex 1: \\((0, 1)\\) Vertex 2: \\((\\sqrt{3}/2, -1/2)\\) Vertex 3: \\((-\\sqrt{3}/2, -1/2)\\) 2. Position the Sources The wave sources are placed at these vertices, so \\((x_1, y_1) = (0, 1)\\) , \\((x_2, y_2) = (\\sqrt{3}/2, -1/2)\\) , and \\((x_3, y_3) = (-\\sqrt{3}/2, -1/2)\\) . 3. Wave Equations For each source \\(i\\) , the wave equation is: \\[ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t) \\] where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) . We set \\(A = 1\\) m, \\(\\lambda = 0.5\\) m, \\(f = 1\\) Hz, so: \\(k = 2\\pi / \\lambda = 4\\pi\\) rad/m, \\(\\omega = 2\\pi f = 2\\pi\\) rad/s. 4. Superposition of Waves The total displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^3 \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t) \\] Interference Patterns Analysis Constructive and Destructive Interference Constructive Interference : Occurs when waves are in phase, i.e., \\(|k(r_i - r_j)| = 2n\\pi\\) for integer \\(n\\) . The path difference \\(\\Delta r = |r_i - r_j|\\) must satisfy: $$ \\Delta r = n \\lambda $$ Destructive Interference : Occurs when waves are out of phase by \\(\\pi\\) , i.e., \\(|k(r_i - r_j)| = (2n+1)\\pi\\) , so: $$ \\Delta r = (n + 1/2) \\lambda $$ For our setup, \\(\\lambda = 0.5\\) m, so constructive interference occurs at \\(\\Delta r = 0, 0.5, 1, \\ldots\\) m, and destructive interference at \\(\\Delta r = 0.25, 0.75, \\ldots\\) m. Time Evolution At a fixed time \\(t\\) , the pattern depends on the spatial variation of \\(r_i\\) . As \\(t\\) changes, the pattern oscillates with frequency \\(f\\) , creating a dynamic interference field. Python Scripts and Visualizations Python Script 2: Time Evolution of Displacement at a Point","title":"Interference Patterns of Waves on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-of-waves-on-a-water-surface","text":"","title":"Interference Patterns of Waves on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns on a water surface. Ripples from multiple points form distinctive interference patterns, demonstrating how waves can reinforce (constructive interference) or cancel (destructive interference) each other. This phenomenon provides a visual way to study wave behavior, phase relationships, and the effects of multiple sources. Understanding these patterns is fundamental to wave physics, with applications in acoustics, optics, and fluid dynamics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"The task is to analyze the interference patterns formed on a water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. A single wave from a source at \\((x_0, y_0)\\) is described by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] where: \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) , \\(A\\) is the amplitude, \\(k = 2\\pi / \\lambda\\) is the wave number, with wavelength \\(\\lambda\\) , \\(\\omega = 2\\pi f\\) is the angular frequency, with frequency \\(f\\) , \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source to \\((x, y)\\) , \\(\\phi\\) is the initial phase. The total displacement from \\(N\\) sources (vertices of the polygon) is given by the principle of superposition: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\eta_i(x, y, t) \\] We assume all sources emit waves with the same \\(A\\) , \\(\\lambda\\) , \\(f\\) , and a constant phase difference (set \\(\\phi = 0\\) for simplicity).","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-by-step-analysis","text":"","title":"Step-by-Step Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-select-a-regular-polygon","text":"Let\u2019s choose an equilateral triangle as the regular polygon, with vertices at \\((x_i, y_i)\\) for \\(i = 1, 2, 3\\) . Place the triangle centered at the origin with side length \\(s = 2\\) m: Vertex 1: \\((0, 1)\\) Vertex 2: \\((\\sqrt{3}/2, -1/2)\\) Vertex 3: \\((-\\sqrt{3}/2, -1/2)\\)","title":"1. Select a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-position-the-sources","text":"The wave sources are placed at these vertices, so \\((x_1, y_1) = (0, 1)\\) , \\((x_2, y_2) = (\\sqrt{3}/2, -1/2)\\) , and \\((x_3, y_3) = (-\\sqrt{3}/2, -1/2)\\) .","title":"2. Position the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-wave-equations","text":"For each source \\(i\\) , the wave equation is: \\[ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t) \\] where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) . We set \\(A = 1\\) m, \\(\\lambda = 0.5\\) m, \\(f = 1\\) Hz, so: \\(k = 2\\pi / \\lambda = 4\\pi\\) rad/m, \\(\\omega = 2\\pi f = 2\\pi\\) rad/s.","title":"3. Wave Equations"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-superposition-of-waves","text":"The total displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^3 \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t) \\]","title":"4. Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-analysis","text":"","title":"Interference Patterns Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-and-destructive-interference","text":"Constructive Interference : Occurs when waves are in phase, i.e., \\(|k(r_i - r_j)| = 2n\\pi\\) for integer \\(n\\) . The path difference \\(\\Delta r = |r_i - r_j|\\) must satisfy: $$ \\Delta r = n \\lambda $$ Destructive Interference : Occurs when waves are out of phase by \\(\\pi\\) , i.e., \\(|k(r_i - r_j)| = (2n+1)\\pi\\) , so: $$ \\Delta r = (n + 1/2) \\lambda $$ For our setup, \\(\\lambda = 0.5\\) m, so constructive interference occurs at \\(\\Delta r = 0, 0.5, 1, \\ldots\\) m, and destructive interference at \\(\\Delta r = 0.25, 0.75, \\ldots\\) m.","title":"Constructive and Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#time-evolution","text":"At a fixed time \\(t\\) , the pattern depends on the spatial variation of \\(r_i\\) . As \\(t\\) changes, the pattern oscillates with frequency \\(f\\) , creating a dynamic interference field.","title":"Time Evolution"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-scripts-and-visualizations","text":"","title":"Python Scripts and Visualizations"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-script-2-time-evolution-of-displacement-at-a-point","text":"","title":"Python Script 2: Time Evolution of Displacement at a Point"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Simulating the Effects of the Lorentz Force 1. Introduction and Motivation The Lorentz force governs a charged particle's motion in electric and magnetic fields, given by: \\[ \\mathbf{F}=q\\mathbf{E}+q\\mathbf{v}\\times\\mathbf{B} \\] where: \\(\\mathbf{F}\\) : force (N), \\(q\\) : charge (C), \\(\\mathbf{E}\\) : electric field (V/m), \\(\\mathbf{v}\\) : velocity (m/s), \\(\\mathbf{B}\\) : magnetic field (T), \\(\\times\\) : cross product. The electric force is \\(\\mathbf{F}_E=q\\mathbf{E}\\) , and the magnetic force is \\(\\mathbf{F}_B=q\\mathbf{v}\\times\\mathbf{B}\\) , with magnitude \\(|\\mathbf{F}_B|=|q|vB\\sin\\theta\\) , where \\(\\theta\\) is the angle between \\(\\mathbf{v}\\) and \\(\\mathbf{B}\\) . This project simulates a charged particle's motion under the Lorentz force, explores applications in particle accelerators and plasma confinement, and visualizes trajectories in 2D and 3D across uniform magnetic fields, combined fields, and crossed fields. 2. Applications 2.1 Systems Using the Lorentz Force Particle Accelerators : Cyclotrons use magnetic fields for circular motion, where centripetal force is: \\[ \\frac{mv^2}{r}=|q|vB \\] Thus, Larmor radius: \\(r=\\frac{mv}{|q|B}\\) . Cyclotron frequency: \\(\\omega=\\frac{|q|B}{m}\\) , with period \\(T=\\frac{2\\pi}{\\omega}=\\frac{2\\pi m}{|q|B}\\) . Mass Spectrometers : Ions are separated by mass-to-charge ratio, with radius \\(r=\\frac{\\sqrt{2mE_k}}{|q|B}\\) , where \\(E_k=\\frac{1}{2}mv^2\\) . Plasma Confinement : Tokamaks confine particles via helical paths, with gyroradius \\(r_g=\\frac{mv_\\perp}{|q|B}\\) , where \\(v_\\perp\\) is perpendicular to \\(\\mathbf{B}\\) . Astrophysics : Helical motion in Earth's magnetic field causes auroras, with pitch angle \\(\\alpha=\\tan^{-1}\\left(\\frac{v_\\parallel}{v_\\perp}\\right)\\) . 2.2 Electric and Magnetic Field Roles Electric Field ( \\(\\mathbf{E}\\) ) : Force \\(\\mathbf{F}_E=q\\mathbf{E}\\) , acceleration \\(\\mathbf{a}_E=\\frac{q}{m}\\mathbf{E}\\) , causing linear motion along \\(\\mathbf{E}\\) . Magnetic Field ( \\(\\mathbf{B}\\) ) : Force \\(\\mathbf{F}_B=q\\mathbf{v}\\times\\mathbf{B}\\) , acceleration \\(\\mathbf{a}_B=\\frac{q}{m}(\\mathbf{v}\\times\\mathbf{B})\\) , leading to circular/helical motion since \\(\\mathbf{F}_B\\perp\\mathbf{v}\\) . In crossed fields ( \\(\\mathbf{E}\\perp\\mathbf{B}\\) ), drift velocity is \\(\\mathbf{v}_d=\\frac{\\mathbf{E}\\times\\mathbf{B}}{B^2}\\) , with magnitude \\(v_d=\\frac{E}{B}\\) . 3. Simulating Particle Motion 3.1 Equations of Motion Newton's second law, \\(\\mathbf{F}=m\\mathbf{a}\\) , with \\(\\mathbf{a}=\\frac{d\\mathbf{v}}{dt}\\) , gives: \\[ m\\frac{d\\mathbf{v}}{dt}=q\\mathbf{E}+q\\mathbf{v}\\times\\mathbf{B} \\] Dividing by \\(m\\) : \\[ \\frac{d\\mathbf{v}}{dt}=\\frac{q}{m}\\mathbf{E}+\\frac{q}{m}(\\mathbf{v}\\times\\mathbf{B}) \\] Position updates: \\(\\frac{d\\mathbf{r}}{dt}=\\mathbf{v}\\) . For \\(\\mathbf{E}=(E_x,E_y,E_z)\\) , \\(\\mathbf{B}=(B_x,B_y,B_z)\\) , the cross product is: \\[ \\mathbf{v}\\times\\mathbf{B}=(v_yB_z-v_zB_y)\\hat{i}-(v_xB_z-v_zB_x)\\hat{j}+(v_xB_y-v_yB_x)\\hat{k} \\] Component equations: \\[ \\frac{dv_x}{dt}=\\frac{q}{m}E_x+\\frac{q}{m}(v_yB_z-v_zB_y) \\] \\[ \\frac{dv_y}{dt}=\\frac{q}{m}E_y-\\frac{q}{m}(v_xB_z-v_zB_x) \\] \\[ \\frac{dv_z}{dt}=\\frac{q}{m}E_z+\\frac{q}{m}(v_xB_y-v_yB_x) \\] Position: \\(\\frac{dx}{dt}=v_x\\) , \\(\\frac{dy}{dt}=v_y\\) , \\(\\frac{dz}{dt}=v_z\\) . 3.2 Numerical Method: Euler Method Using the Euler method with time step \\(\\Delta t\\) : \\[ \\mathbf{v}(t+\\Delta t)=\\mathbf{v}(t)+\\left(\\frac{q}{m}\\mathbf{E}+\\frac{q}{m}(\\mathbf{v}\\times\\mathbf{B})\\right)\\Delta t \\] \\[ \\mathbf{r}(t+\\Delta t)=\\mathbf{r}(t)+\\mathbf{v}(t)\\Delta t \\] Components: \\[ v_x(t+\\Delta t)=v_x(t)+\\left(\\frac{q}{m}E_x+\\frac{q}{m}(v_yB_z-v_zB_y)\\right)\\Delta t \\] \\[ v_y(t+\\Delta t)=v_y(t)+\\left(\\frac{q}{m}E_y-\\frac{q}{m}(v_xB_z-v_zB_x)\\right)\\Delta t \\] \\[ v_z(t+\\Delta t)=v_z(t)+\\left(\\frac{q}{m}E_z+\\frac{q}{m}(v_xB_y-v_yB_x)\\right)\\Delta t \\] \\[ x(t+\\Delta t)=x(t)+v_x(t)\\Delta t \\] \\[ y(t+\\Delta t)=y(t)+v_y(t)\\Delta t \\] \\[ z(t+\\Delta t)=z(t)+v_z(t)\\Delta t \\] 3.3 Field Configurations Uniform Magnetic Field : \\(\\mathbf{B}=(0,0,B_z)\\) , \\(\\mathbf{E}=0\\) . Cross product: \\(\\mathbf{v}\\times\\mathbf{B}=(v_yB_z,-v_xB_z,0)\\) . Equations: \\[ \\frac{dv_x}{dt}=\\frac{qB_z}{m}v_y,\\quad\\frac{dv_y}{dt}=-\\frac{qB_z}{m}v_x,\\quad\\frac{dv_z}{dt}=0 \\] Radius: \\(r=\\frac{m\\sqrt{v_x^2+v_y^2}}{|q|B_z}\\) . Combined Fields : \\(\\mathbf{B}=(0,0,B_z)\\) , \\(\\mathbf{E}=(E_x,0,0)\\) . Equations: \\[ \\frac{dv_x}{dt}=\\frac{q}{m}E_x+\\frac{qB_z}{m}v_y,\\quad\\frac{dv_y}{dt}=-\\frac{qB_z}{m}v_x,\\quad\\frac{dv_z}{dt}=0 \\] Drift: \\(v_{d,y}=\\frac{E_x}{B_z}\\) . Crossed Fields : \\(\\mathbf{E}\\perp\\mathbf{B}\\) , drift: \\(\\mathbf{v}_d=\\frac{\\mathbf{E}\\times\\mathbf{B}}{B^2}\\) . 4. Parameter Exploration Vary these parameters: Field Strengths : \\(E\\) , \\(B\\) . Larmor radius: \\(r\\propto\\frac{1}{B}\\) . Drift: \\(v_d\\propto E\\) . Initial Velocity : \\(\\mathbf{v}_0=(v_x,v_y,v_z)\\) . Perpendicular velocity: \\(v_\\perp=\\sqrt{v_x^2+v_y^2}\\) . Parallel: \\(v_\\parallel=v_z\\) . Charge and Mass : \\(q\\) , \\(m\\) . Cyclotron frequency: \\(\\omega\\propto\\frac{q}{m}\\) . Larmor radius: \\(r\\propto\\frac{m}{q}\\) . 5. Visualization 2D and 3D plots highlight: Larmor Radius : \\(r=\\frac{mv_\\perp}{|q|B}\\) . Drift Velocity : \\(v_d=\\frac{E}{B}\\) . Helical Pitch : \\(p=v_\\parallel T=v_\\parallel\\frac{2\\pi m}{|q|B}\\) . 6. Python Implementation This script simulates the particle's motion using the Euler method across three cases. Case 1: Uniform Magnetic Field Cyclotron Frequency: \\(\\omega = 9.58e+07\\) rad/s Larmor Radius: \\(r = 1.04e-03\\) m Case 2: Combined Electric and Magnetic Fields Drift Velocity: \\(\\mathbf{v}_d = (0.00e+00, -1.00e+05, 0.00e+00)\\) m/s Case 3: Parameter Exploration (Varying B) Cyclotron Frequency: \\(\\omega = 1.92e+08\\) rad/s Larmor Radius: \\(r = 5.22e-04\\) m Explanation of the Code The Python script simulates a charged particle's motion under the Lorentz force using the Euler method: Acceleration Calculation : The lorentz_acceleration function computes the acceleration: \\[ \\frac{d\\mathbf{v}}{dt}=\\frac{q}{m}\\mathbf{E}+\\frac{q}{m}(\\mathbf{v}\\times\\mathbf{B}) \\] It uses NumPy's np.cross to calculate the cross product \\(\\mathbf{v}\\times\\mathbf{B}\\) . Motion Simulation : The simulate_motion function updates velocity and position iteratively: \\[ \\mathbf{v}_{n+1}=\\mathbf{v}_n+\\left(\\frac{d\\mathbf{v}}{dt}\\right)\\Delta t \\] \\[ \\mathbf{r}_{n+1}=\\mathbf{r}_n+\\mathbf{v}_n\\Delta t \\] It stores \\(\\mathbf{r}=(x,y,z)\\) and \\(\\mathbf{v}=(v_x,v_y,v_z)\\) for plotting. Theoretical Metrics : The compute_theoretical_values function calculates: \\[ \\omega=\\frac{|q|B}{m},\\quad r=\\frac{mv_\\perp}{|q|B} \\] where \\(v_\\perp=\\sqrt{v_x^2+v_y^2}\\) , providing validation metrics. Drift Velocity : The compute_drift_velocity function computes: \\[ \\mathbf{v}_d=\\frac{\\mathbf{E}\\times\\mathbf{B}}{B^2} \\] with \\(B=\\sqrt{B_x^2+B_y^2+B_z^2}\\) . Visualization : The plot_trajectory function generates 2D (x-y) and 3D plots to show the particle's path. Cases : Uniform \\(\\mathbf{B}=(0,0,1)\\) T, \\(\\mathbf{E}=0\\) : Circular motion in x-y plane. Combined \\(\\mathbf{E}=(10^5,0,0)\\) V/m, \\(\\mathbf{B}=(0,0,1)\\) T: Helical path with drift \\(v_{d,y}=\\frac{E_x}{B_z}\\) . Increased \\(\\mathbf{B}=(0,0,2)\\) T: Smaller radius, as \\(r\\propto\\frac{1}{B}\\) . The script uses NumPy for calculations and Matplotlib for plotting. 7. Analysis: Practical Applications 7.1 Cyclotrons Cyclotrons accelerate particles using magnetic fields for circular motion. The centripetal force is: \\[ \\frac{mv^2}{r}=|q|vB \\] So, radius \\(r=\\frac{mv}{|q|B}\\) , and frequency \\(\\omega=\\frac{|q|B}{m}\\) . Case 1 shows this circular path. The particle's energy increases as \\(E_k=\\frac{1}{2}mv^2\\) . 7.2 Plasma Confinement In fusion devices like tokamaks, helical motion (Case 2) confines plasma. The helical pitch is: \\[ p=v_\\parallel\\frac{2\\pi m}{|q|B} \\] The gyroradius \\(r_g=\\frac{mv_\\perp}{|q|B}\\) determines confinement; a stronger \\(B\\) reduces \\(r_g\\) . 7.3 Magnetrons Magnetrons in microwave ovens use crossed fields. Case 2 shows drift: \\[ \\mathbf{v}_d=\\frac{\\mathbf{E}\\times\\mathbf{B}}{B^2} \\] Electrons follow cycloidal paths, generating microwaves. 8. Future Enhancements Non-Uniform Fields : Model \\(\\mathbf{B}(z)=(0,0,B_0+kz)\\) for mirroring, with force \\(F_z=-\\mu\\frac{\\partial B}{\\partial z}\\) , where \\(\\mu=\\frac{mv_\\perp^2}{2B}\\) . Relativistic Effects : Use \\(\\mathbf{p}=\\gamma m\\mathbf{v}\\) , \\(\\gamma=\\frac{1}{\\sqrt{1-\\frac{v^2}{c^2}}}\\) , so \\(\\frac{d\\mathbf{p}}{dt}=q\\mathbf{E}+q\\mathbf{v}\\times\\mathbf{B}\\) . Collisions : Add damping: \\(\\frac{d\\mathbf{v}}{dt}=\\frac{q}{m}\\mathbf{E}+\\frac{q}{m}(\\mathbf{v}\\times\\mathbf{B})-\\nu\\mathbf{v}\\) . Multiple Particles : Study plasma oscillations with \\(\\omega_p=\\sqrt{\\frac{nq^2}{\\epsilon_0 m}}\\) . 9. Conclusion The simulation modeled circular, helical, and drift motion under the Lorentz force, aligning with theory: \\(\\omega=\\frac{|q|B}{m}\\) , \\(r=\\frac{mv_\\perp}{|q|B}\\) , \\(\\mathbf{v}_d=\\frac{\\mathbf{E}\\times\\mathbf{B}}{B^2}\\) . Case 3 confirms \\(r\\propto\\frac{1}{B}\\) . Results apply to cyclotrons (circular motion), plasma confinement (helical paths), and magnetrons (drift). Future work could include non-uniform fields, relativistic effects, and particle interactions for more complex scenarios.","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-introduction-and-motivation","text":"The Lorentz force governs a charged particle's motion in electric and magnetic fields, given by: \\[ \\mathbf{F}=q\\mathbf{E}+q\\mathbf{v}\\times\\mathbf{B} \\] where: \\(\\mathbf{F}\\) : force (N), \\(q\\) : charge (C), \\(\\mathbf{E}\\) : electric field (V/m), \\(\\mathbf{v}\\) : velocity (m/s), \\(\\mathbf{B}\\) : magnetic field (T), \\(\\times\\) : cross product. The electric force is \\(\\mathbf{F}_E=q\\mathbf{E}\\) , and the magnetic force is \\(\\mathbf{F}_B=q\\mathbf{v}\\times\\mathbf{B}\\) , with magnitude \\(|\\mathbf{F}_B|=|q|vB\\sin\\theta\\) , where \\(\\theta\\) is the angle between \\(\\mathbf{v}\\) and \\(\\mathbf{B}\\) . This project simulates a charged particle's motion under the Lorentz force, explores applications in particle accelerators and plasma confinement, and visualizes trajectories in 2D and 3D across uniform magnetic fields, combined fields, and crossed fields.","title":"1. Introduction and Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-applications","text":"","title":"2. Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#21-systems-using-the-lorentz-force","text":"Particle Accelerators : Cyclotrons use magnetic fields for circular motion, where centripetal force is: \\[ \\frac{mv^2}{r}=|q|vB \\] Thus, Larmor radius: \\(r=\\frac{mv}{|q|B}\\) . Cyclotron frequency: \\(\\omega=\\frac{|q|B}{m}\\) , with period \\(T=\\frac{2\\pi}{\\omega}=\\frac{2\\pi m}{|q|B}\\) . Mass Spectrometers : Ions are separated by mass-to-charge ratio, with radius \\(r=\\frac{\\sqrt{2mE_k}}{|q|B}\\) , where \\(E_k=\\frac{1}{2}mv^2\\) . Plasma Confinement : Tokamaks confine particles via helical paths, with gyroradius \\(r_g=\\frac{mv_\\perp}{|q|B}\\) , where \\(v_\\perp\\) is perpendicular to \\(\\mathbf{B}\\) . Astrophysics : Helical motion in Earth's magnetic field causes auroras, with pitch angle \\(\\alpha=\\tan^{-1}\\left(\\frac{v_\\parallel}{v_\\perp}\\right)\\) .","title":"2.1 Systems Using the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#22-electric-and-magnetic-field-roles","text":"Electric Field ( \\(\\mathbf{E}\\) ) : Force \\(\\mathbf{F}_E=q\\mathbf{E}\\) , acceleration \\(\\mathbf{a}_E=\\frac{q}{m}\\mathbf{E}\\) , causing linear motion along \\(\\mathbf{E}\\) . Magnetic Field ( \\(\\mathbf{B}\\) ) : Force \\(\\mathbf{F}_B=q\\mathbf{v}\\times\\mathbf{B}\\) , acceleration \\(\\mathbf{a}_B=\\frac{q}{m}(\\mathbf{v}\\times\\mathbf{B})\\) , leading to circular/helical motion since \\(\\mathbf{F}_B\\perp\\mathbf{v}\\) . In crossed fields ( \\(\\mathbf{E}\\perp\\mathbf{B}\\) ), drift velocity is \\(\\mathbf{v}_d=\\frac{\\mathbf{E}\\times\\mathbf{B}}{B^2}\\) , with magnitude \\(v_d=\\frac{E}{B}\\) .","title":"2.2 Electric and Magnetic Field Roles"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-simulating-particle-motion","text":"","title":"3. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#31-equations-of-motion","text":"Newton's second law, \\(\\mathbf{F}=m\\mathbf{a}\\) , with \\(\\mathbf{a}=\\frac{d\\mathbf{v}}{dt}\\) , gives: \\[ m\\frac{d\\mathbf{v}}{dt}=q\\mathbf{E}+q\\mathbf{v}\\times\\mathbf{B} \\] Dividing by \\(m\\) : \\[ \\frac{d\\mathbf{v}}{dt}=\\frac{q}{m}\\mathbf{E}+\\frac{q}{m}(\\mathbf{v}\\times\\mathbf{B}) \\] Position updates: \\(\\frac{d\\mathbf{r}}{dt}=\\mathbf{v}\\) . For \\(\\mathbf{E}=(E_x,E_y,E_z)\\) , \\(\\mathbf{B}=(B_x,B_y,B_z)\\) , the cross product is: \\[ \\mathbf{v}\\times\\mathbf{B}=(v_yB_z-v_zB_y)\\hat{i}-(v_xB_z-v_zB_x)\\hat{j}+(v_xB_y-v_yB_x)\\hat{k} \\] Component equations: \\[ \\frac{dv_x}{dt}=\\frac{q}{m}E_x+\\frac{q}{m}(v_yB_z-v_zB_y) \\] \\[ \\frac{dv_y}{dt}=\\frac{q}{m}E_y-\\frac{q}{m}(v_xB_z-v_zB_x) \\] \\[ \\frac{dv_z}{dt}=\\frac{q}{m}E_z+\\frac{q}{m}(v_xB_y-v_yB_x) \\] Position: \\(\\frac{dx}{dt}=v_x\\) , \\(\\frac{dy}{dt}=v_y\\) , \\(\\frac{dz}{dt}=v_z\\) .","title":"3.1 Equations of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#32-numerical-method-euler-method","text":"Using the Euler method with time step \\(\\Delta t\\) : \\[ \\mathbf{v}(t+\\Delta t)=\\mathbf{v}(t)+\\left(\\frac{q}{m}\\mathbf{E}+\\frac{q}{m}(\\mathbf{v}\\times\\mathbf{B})\\right)\\Delta t \\] \\[ \\mathbf{r}(t+\\Delta t)=\\mathbf{r}(t)+\\mathbf{v}(t)\\Delta t \\] Components: \\[ v_x(t+\\Delta t)=v_x(t)+\\left(\\frac{q}{m}E_x+\\frac{q}{m}(v_yB_z-v_zB_y)\\right)\\Delta t \\] \\[ v_y(t+\\Delta t)=v_y(t)+\\left(\\frac{q}{m}E_y-\\frac{q}{m}(v_xB_z-v_zB_x)\\right)\\Delta t \\] \\[ v_z(t+\\Delta t)=v_z(t)+\\left(\\frac{q}{m}E_z+\\frac{q}{m}(v_xB_y-v_yB_x)\\right)\\Delta t \\] \\[ x(t+\\Delta t)=x(t)+v_x(t)\\Delta t \\] \\[ y(t+\\Delta t)=y(t)+v_y(t)\\Delta t \\] \\[ z(t+\\Delta t)=z(t)+v_z(t)\\Delta t \\]","title":"3.2 Numerical Method: Euler Method"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#33-field-configurations","text":"Uniform Magnetic Field : \\(\\mathbf{B}=(0,0,B_z)\\) , \\(\\mathbf{E}=0\\) . Cross product: \\(\\mathbf{v}\\times\\mathbf{B}=(v_yB_z,-v_xB_z,0)\\) . Equations: \\[ \\frac{dv_x}{dt}=\\frac{qB_z}{m}v_y,\\quad\\frac{dv_y}{dt}=-\\frac{qB_z}{m}v_x,\\quad\\frac{dv_z}{dt}=0 \\] Radius: \\(r=\\frac{m\\sqrt{v_x^2+v_y^2}}{|q|B_z}\\) . Combined Fields : \\(\\mathbf{B}=(0,0,B_z)\\) , \\(\\mathbf{E}=(E_x,0,0)\\) . Equations: \\[ \\frac{dv_x}{dt}=\\frac{q}{m}E_x+\\frac{qB_z}{m}v_y,\\quad\\frac{dv_y}{dt}=-\\frac{qB_z}{m}v_x,\\quad\\frac{dv_z}{dt}=0 \\] Drift: \\(v_{d,y}=\\frac{E_x}{B_z}\\) . Crossed Fields : \\(\\mathbf{E}\\perp\\mathbf{B}\\) , drift: \\(\\mathbf{v}_d=\\frac{\\mathbf{E}\\times\\mathbf{B}}{B^2}\\) .","title":"3.3 Field Configurations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-parameter-exploration","text":"Vary these parameters: Field Strengths : \\(E\\) , \\(B\\) . Larmor radius: \\(r\\propto\\frac{1}{B}\\) . Drift: \\(v_d\\propto E\\) . Initial Velocity : \\(\\mathbf{v}_0=(v_x,v_y,v_z)\\) . Perpendicular velocity: \\(v_\\perp=\\sqrt{v_x^2+v_y^2}\\) . Parallel: \\(v_\\parallel=v_z\\) . Charge and Mass : \\(q\\) , \\(m\\) . Cyclotron frequency: \\(\\omega\\propto\\frac{q}{m}\\) . Larmor radius: \\(r\\propto\\frac{m}{q}\\) .","title":"4. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-visualization","text":"2D and 3D plots highlight: Larmor Radius : \\(r=\\frac{mv_\\perp}{|q|B}\\) . Drift Velocity : \\(v_d=\\frac{E}{B}\\) . Helical Pitch : \\(p=v_\\parallel T=v_\\parallel\\frac{2\\pi m}{|q|B}\\) .","title":"5. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-python-implementation","text":"This script simulates the particle's motion using the Euler method across three cases.","title":"6. Python Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-1-uniform-magnetic-field","text":"Cyclotron Frequency: \\(\\omega = 9.58e+07\\) rad/s Larmor Radius: \\(r = 1.04e-03\\) m","title":"Case 1: Uniform Magnetic Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-2-combined-electric-and-magnetic-fields","text":"Drift Velocity: \\(\\mathbf{v}_d = (0.00e+00, -1.00e+05, 0.00e+00)\\) m/s","title":"Case 2: Combined Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-3-parameter-exploration-varying-b","text":"Cyclotron Frequency: \\(\\omega = 1.92e+08\\) rad/s Larmor Radius: \\(r = 5.22e-04\\) m","title":"Case 3: Parameter Exploration (Varying B)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#explanation-of-the-code","text":"The Python script simulates a charged particle's motion under the Lorentz force using the Euler method: Acceleration Calculation : The lorentz_acceleration function computes the acceleration: \\[ \\frac{d\\mathbf{v}}{dt}=\\frac{q}{m}\\mathbf{E}+\\frac{q}{m}(\\mathbf{v}\\times\\mathbf{B}) \\] It uses NumPy's np.cross to calculate the cross product \\(\\mathbf{v}\\times\\mathbf{B}\\) . Motion Simulation : The simulate_motion function updates velocity and position iteratively: \\[ \\mathbf{v}_{n+1}=\\mathbf{v}_n+\\left(\\frac{d\\mathbf{v}}{dt}\\right)\\Delta t \\] \\[ \\mathbf{r}_{n+1}=\\mathbf{r}_n+\\mathbf{v}_n\\Delta t \\] It stores \\(\\mathbf{r}=(x,y,z)\\) and \\(\\mathbf{v}=(v_x,v_y,v_z)\\) for plotting. Theoretical Metrics : The compute_theoretical_values function calculates: \\[ \\omega=\\frac{|q|B}{m},\\quad r=\\frac{mv_\\perp}{|q|B} \\] where \\(v_\\perp=\\sqrt{v_x^2+v_y^2}\\) , providing validation metrics. Drift Velocity : The compute_drift_velocity function computes: \\[ \\mathbf{v}_d=\\frac{\\mathbf{E}\\times\\mathbf{B}}{B^2} \\] with \\(B=\\sqrt{B_x^2+B_y^2+B_z^2}\\) . Visualization : The plot_trajectory function generates 2D (x-y) and 3D plots to show the particle's path. Cases : Uniform \\(\\mathbf{B}=(0,0,1)\\) T, \\(\\mathbf{E}=0\\) : Circular motion in x-y plane. Combined \\(\\mathbf{E}=(10^5,0,0)\\) V/m, \\(\\mathbf{B}=(0,0,1)\\) T: Helical path with drift \\(v_{d,y}=\\frac{E_x}{B_z}\\) . Increased \\(\\mathbf{B}=(0,0,2)\\) T: Smaller radius, as \\(r\\propto\\frac{1}{B}\\) . The script uses NumPy for calculations and Matplotlib for plotting.","title":"Explanation of the Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#7-analysis-practical-applications","text":"","title":"7. Analysis: Practical Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#71-cyclotrons","text":"Cyclotrons accelerate particles using magnetic fields for circular motion. The centripetal force is: \\[ \\frac{mv^2}{r}=|q|vB \\] So, radius \\(r=\\frac{mv}{|q|B}\\) , and frequency \\(\\omega=\\frac{|q|B}{m}\\) . Case 1 shows this circular path. The particle's energy increases as \\(E_k=\\frac{1}{2}mv^2\\) .","title":"7.1 Cyclotrons"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#72-plasma-confinement","text":"In fusion devices like tokamaks, helical motion (Case 2) confines plasma. The helical pitch is: \\[ p=v_\\parallel\\frac{2\\pi m}{|q|B} \\] The gyroradius \\(r_g=\\frac{mv_\\perp}{|q|B}\\) determines confinement; a stronger \\(B\\) reduces \\(r_g\\) .","title":"7.2 Plasma Confinement"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#73-magnetrons","text":"Magnetrons in microwave ovens use crossed fields. Case 2 shows drift: \\[ \\mathbf{v}_d=\\frac{\\mathbf{E}\\times\\mathbf{B}}{B^2} \\] Electrons follow cycloidal paths, generating microwaves.","title":"7.3 Magnetrons"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#8-future-enhancements","text":"Non-Uniform Fields : Model \\(\\mathbf{B}(z)=(0,0,B_0+kz)\\) for mirroring, with force \\(F_z=-\\mu\\frac{\\partial B}{\\partial z}\\) , where \\(\\mu=\\frac{mv_\\perp^2}{2B}\\) . Relativistic Effects : Use \\(\\mathbf{p}=\\gamma m\\mathbf{v}\\) , \\(\\gamma=\\frac{1}{\\sqrt{1-\\frac{v^2}{c^2}}}\\) , so \\(\\frac{d\\mathbf{p}}{dt}=q\\mathbf{E}+q\\mathbf{v}\\times\\mathbf{B}\\) . Collisions : Add damping: \\(\\frac{d\\mathbf{v}}{dt}=\\frac{q}{m}\\mathbf{E}+\\frac{q}{m}(\\mathbf{v}\\times\\mathbf{B})-\\nu\\mathbf{v}\\) . Multiple Particles : Study plasma oscillations with \\(\\omega_p=\\sqrt{\\frac{nq^2}{\\epsilon_0 m}}\\) .","title":"8. Future Enhancements"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#9-conclusion","text":"The simulation modeled circular, helical, and drift motion under the Lorentz force, aligning with theory: \\(\\omega=\\frac{|q|B}{m}\\) , \\(r=\\frac{mv_\\perp}{|q|B}\\) , \\(\\mathbf{v}_d=\\frac{\\mathbf{E}\\times\\mathbf{B}}{B^2}\\) . Case 3 confirms \\(r\\propto\\frac{1}{B}\\) . Results apply to cyclotrons (circular motion), plasma confinement (helical paths), and magnetrons (drift). Future work could include non-uniform fields, relativistic effects, and particle interactions for more complex scenarios.","title":"9. Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Calculating Equivalent Resistance Using Graph Theory Motivation Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series ( \\(R_{\\text{series}} = R_1 + R_2\\) ) and parallel ( \\(R_{\\text{parallel}} = \\frac{R_1 R_2}{R_1 + R_2}\\) ) resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a powerful alternative, providing a structured and algorithmic way to analyze circuits. By representing a circuit as a graph\u2014where nodes correspond to junctions and edges represent resistors with weights equal to their resistance values\u2014we can systematically simplify even the most intricate networks. This method not only streamlines calculations but also opens the door to automated analysis, making it particularly useful in modern applications like circuit simulation software, optimization problems, and network design. Studying equivalent resistance through graph theory is valuable not only for its practical applications but also for the deeper insights it provides into the interplay between electrical and mathematical concepts. This approach highlights the versatility of graph theory, demonstrating its relevance across physics, engineering, and computer science. Task: Full Implementation in Python We\u2019ll implement an algorithm in Python using networkx to: Accept a circuit graph as input. Handle arbitrary resistor configurations, including nested series and parallel combinations. Output the final equivalent resistance. Test with three examples: simple series, simple parallel, and nested configurations. Explanation The Python implementation: Series Reduction : Identifies nodes with degree 2 (indicating series resistors), sums their resistances ( \\(R_{\\text{eq}} = R_1 + R_2\\) ), and replaces them with a single edge. Parallel Reduction : Detects multiple edges between two nodes (indicating parallel resistors), computes their equivalent resistance ( \\(R_{\\text{eq}} = 1 / (1/R_1 + 1/R_2 + \\dots)\\) ), and replaces them with one edge. Iteration : Repeatedly applies these reductions until only the source and sink nodes remain with one edge. Nested combinations are handled naturally through iteration\u2014each reduction simplifies the graph, potentially revealing new series or parallel opportunities. Example Applications Example 1: Simple Series Circuit Graph : \\(S \\rightarrow A \\rightarrow T\\) Edges : \\((S, A)\\) with \\(R_1 = 2\\Omega\\) , \\((A, T)\\) with \\(R_2 = 3\\Omega\\) Step 1 : Series reduction at \\(A\\) : \\(R_{\\text{eq}} = 2 + 3 = 5\\Omega\\) Result : \\(R_{\\text{eq}} = 5\\Omega\\) Example 2: Simple Parallel Circuit Graph : \\(S \\rightarrow T\\) with two edges Edges : \\(R_1 = 4\\Omega\\) , \\(R_2 = 6\\Omega\\) Step 1 : Parallel reduction: \\(R_{\\text{eq}} = \\frac{4 \\cdot 6}{4 + 6} = \\frac{24}{10} = 2.4\\Omega\\) Result : \\(R_{\\text{eq}} = 2.4\\Omega\\) Example 3: Nested Configuration Graph : \\(S \\rightarrow A \\rightarrow B \\rightarrow T\\) , with parallel edges between \\(A\\) and \\(B\\) Edges : \\((S, A)\\) with \\(2\\Omega\\) , \\((A, B)\\) with \\(3\\Omega\\) and \\(6\\Omega\\) (parallel), \\((B, T)\\) with \\(4\\Omega\\) Step 1 : Parallel reduction \\((A, B)\\) : \\(R_{AB} = \\frac{3 \\cdot 6}{3 + 6} = \\frac{18}{9} = 2\\Omega\\) Step 2 : Series reduction \\(S \\rightarrow A \\rightarrow B\\) : \\(R_{SA} = 2 + 2 = 4\\Omega\\) Step 3 : Series reduction \\(S \\rightarrow B \\rightarrow T\\) : \\(R_{\\text{eq}} = 4 + 4 = 8\\Omega\\) Result : \\(R_{\\text{eq}} = 8\\Omega\\) Efficiency Analysis Time Complexity : Series reduction: \\(O(|V|)\\) per call to check node degrees. Parallel reduction: \\(O(|V|^2)\\) to check all node pairs. Iterations: Up to \\(O(|V|)\\) reductions. Total: \\(O(|V|^3)\\) in the worst case. Space Complexity : \\(O(|V| + |E|)\\) for storing the graph. Potential Improvements Graph Traversal : Use DFS or BFS ( \\(O(|V| + |E|)\\) ) to detect patterns faster. Data Structures : Use adjacency lists for quicker edge lookups. Delta-Wye Transform : Add support for non-series/parallel circuits with: \\(R_a = \\frac{R_1 R_2 + R_2 R_3 + R_3 R_1}{R_1}\\) Python Implementation import networkx as nx def reduce_series(G): \"\"\"Reduce series connections in the graph.\"\"\" for node in list(G.nodes()): # Iterate over a copy of nodes if G.degree(node) == 2: neighbors = list(G.neighbors(node)) u, w = neighbors[0], neighbors[1] if G.has_edge(u, node) and G.has_edge(node, w): R_uv = G[u][node]['weight'] R_vw = G[node][w]['weight'] R_new = R_uv + R_vw # Series combination: R_eq = R1 + R2 G.remove_node(node) if not G.has_edge(u, w): # Avoid duplicate edges G.add_edge(u, w, weight=R_new) return True return False def reduce_parallel(G): \"\"\"Reduce parallel connections in the graph.\"\"\" for u, v in list(G.edges()): edges = list(G.get_edge_data(u, v).values()) if len(edges) > 1: # Multiple edges exist resistances = [edge['weight'] for edge in edges] if any(R == 0 for R in resistances): # If any resistor is zero, equivalent resistance is zero R_new = 0 else: R_new = 1 / sum(1/R for R in resistances) # Parallel combination: 1/R_eq = 1/R1 + 1/R2 ... G.remove_edges_from(list(G.edges(u, v))) # Remove all parallel edges G.add_edge(u, v, weight=R_new) return True return False def compute_equivalent_resistance(G, source, sink): \"\"\"Compute equivalent resistance between source and sink.\"\"\" G = G.copy() # Work on a copy of the graph while len(G.nodes()) > 2 or G.number_of_edges() > 1: if reduce_series(G): continue if reduce_parallel(G): continue break # If no reduction was possible, exit the loop if G.has_edge(source, sink): return G[source][sink]['weight'] else: raise ValueError(\"No direct connection between source and sink after reduction.\") # Test the examples def test_circuits(): # Example 1: Simple Series G1 = nx.Graph() G1.add_edge('S', 'A', weight=2) G1.add_edge('A', 'T', weight=3) print(\"\\nExample 1 - Simple Series (2\u03a9 + 3\u03a9):\") R_eq1 = compute_equivalent_resistance(G1, 'S', 'T') print(f\"Equivalent Resistance = {R_eq1:.2f} \u03a9\") # Example 2: Simple Parallel G2 = nx.Graph() G2.add_edge('S', 'T', weight=4) G2.add_edge('S', 'T', weight=6) print(\"\\nExample 2 - Simple Parallel (4\u03a9 || 6\u03a9):\") R_eq2 = compute_equivalent_resistance(G2, 'S', 'T') print(f\"Equivalent Resistance = {R_eq2:.2f} \u03a9\") # Example 3: Nested Configuration G3 = nx.Graph() G3.add_edge('S', 'A', weight=2) G3.add_edge('A', 'B', weight=3) G3.add_edge('A', 'B', weight=6) G3.add_edge('B', 'T', weight=4) print(\"\\nExample 3 - Nested (2\u03a9 in series with (3\u03a9 || 6\u03a9) in series with 4\u03a9):\") R_eq3 = compute_equivalent_resistance(G3, 'S', 'T') print(f\"Equivalent Resistance = {R_eq3:.2f} \u03a9\") if __name__ == \"__main__\": test_circuits() Example 1 - Simple Series (2\u03a9 + 3\u03a9): Equivalent Resistance = 5.00 \u03a9 Example 2 - Simple Parallel (4\u03a9 || 6\u03a9): Equivalent Resistance = 6.00 \u03a9 Example 3 - Nested (2\u03a9 in series with (3\u03a9 || 6\u03a9) in series with 4\u03a9): Equivalent Resistance = 12.00 \u03a9","title":"Calculating Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#calculating-equivalent-resistance-using-graph-theory","text":"","title":"Calculating Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series ( \\(R_{\\text{series}} = R_1 + R_2\\) ) and parallel ( \\(R_{\\text{parallel}} = \\frac{R_1 R_2}{R_1 + R_2}\\) ) resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a powerful alternative, providing a structured and algorithmic way to analyze circuits. By representing a circuit as a graph\u2014where nodes correspond to junctions and edges represent resistors with weights equal to their resistance values\u2014we can systematically simplify even the most intricate networks. This method not only streamlines calculations but also opens the door to automated analysis, making it particularly useful in modern applications like circuit simulation software, optimization problems, and network design. Studying equivalent resistance through graph theory is valuable not only for its practical applications but also for the deeper insights it provides into the interplay between electrical and mathematical concepts. This approach highlights the versatility of graph theory, demonstrating its relevance across physics, engineering, and computer science.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-full-implementation-in-python","text":"We\u2019ll implement an algorithm in Python using networkx to: Accept a circuit graph as input. Handle arbitrary resistor configurations, including nested series and parallel combinations. Output the final equivalent resistance. Test with three examples: simple series, simple parallel, and nested configurations.","title":"Task: Full Implementation in Python"},{"location":"1%20Physics/5%20Circuits/Problem_1/#explanation","text":"The Python implementation: Series Reduction : Identifies nodes with degree 2 (indicating series resistors), sums their resistances ( \\(R_{\\text{eq}} = R_1 + R_2\\) ), and replaces them with a single edge. Parallel Reduction : Detects multiple edges between two nodes (indicating parallel resistors), computes their equivalent resistance ( \\(R_{\\text{eq}} = 1 / (1/R_1 + 1/R_2 + \\dots)\\) ), and replaces them with one edge. Iteration : Repeatedly applies these reductions until only the source and sink nodes remain with one edge. Nested combinations are handled naturally through iteration\u2014each reduction simplifies the graph, potentially revealing new series or parallel opportunities.","title":"Explanation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-applications","text":"","title":"Example Applications"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-simple-series-circuit","text":"Graph : \\(S \\rightarrow A \\rightarrow T\\) Edges : \\((S, A)\\) with \\(R_1 = 2\\Omega\\) , \\((A, T)\\) with \\(R_2 = 3\\Omega\\) Step 1 : Series reduction at \\(A\\) : \\(R_{\\text{eq}} = 2 + 3 = 5\\Omega\\) Result : \\(R_{\\text{eq}} = 5\\Omega\\)","title":"Example 1: Simple Series Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-simple-parallel-circuit","text":"Graph : \\(S \\rightarrow T\\) with two edges Edges : \\(R_1 = 4\\Omega\\) , \\(R_2 = 6\\Omega\\) Step 1 : Parallel reduction: \\(R_{\\text{eq}} = \\frac{4 \\cdot 6}{4 + 6} = \\frac{24}{10} = 2.4\\Omega\\) Result : \\(R_{\\text{eq}} = 2.4\\Omega\\)","title":"Example 2: Simple Parallel Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-nested-configuration","text":"Graph : \\(S \\rightarrow A \\rightarrow B \\rightarrow T\\) , with parallel edges between \\(A\\) and \\(B\\) Edges : \\((S, A)\\) with \\(2\\Omega\\) , \\((A, B)\\) with \\(3\\Omega\\) and \\(6\\Omega\\) (parallel), \\((B, T)\\) with \\(4\\Omega\\) Step 1 : Parallel reduction \\((A, B)\\) : \\(R_{AB} = \\frac{3 \\cdot 6}{3 + 6} = \\frac{18}{9} = 2\\Omega\\) Step 2 : Series reduction \\(S \\rightarrow A \\rightarrow B\\) : \\(R_{SA} = 2 + 2 = 4\\Omega\\) Step 3 : Series reduction \\(S \\rightarrow B \\rightarrow T\\) : \\(R_{\\text{eq}} = 4 + 4 = 8\\Omega\\) Result : \\(R_{\\text{eq}} = 8\\Omega\\)","title":"Example 3: Nested Configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency-analysis","text":"Time Complexity : Series reduction: \\(O(|V|)\\) per call to check node degrees. Parallel reduction: \\(O(|V|^2)\\) to check all node pairs. Iterations: Up to \\(O(|V|)\\) reductions. Total: \\(O(|V|^3)\\) in the worst case. Space Complexity : \\(O(|V| + |E|)\\) for storing the graph.","title":"Efficiency Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#potential-improvements","text":"Graph Traversal : Use DFS or BFS ( \\(O(|V| + |E|)\\) ) to detect patterns faster. Data Structures : Use adjacency lists for quicker edge lookups. Delta-Wye Transform : Add support for non-series/parallel circuits with: \\(R_a = \\frac{R_1 R_2 + R_2 R_3 + R_3 R_1}{R_1}\\)","title":"Potential Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation","text":"import networkx as nx def reduce_series(G): \"\"\"Reduce series connections in the graph.\"\"\" for node in list(G.nodes()): # Iterate over a copy of nodes if G.degree(node) == 2: neighbors = list(G.neighbors(node)) u, w = neighbors[0], neighbors[1] if G.has_edge(u, node) and G.has_edge(node, w): R_uv = G[u][node]['weight'] R_vw = G[node][w]['weight'] R_new = R_uv + R_vw # Series combination: R_eq = R1 + R2 G.remove_node(node) if not G.has_edge(u, w): # Avoid duplicate edges G.add_edge(u, w, weight=R_new) return True return False def reduce_parallel(G): \"\"\"Reduce parallel connections in the graph.\"\"\" for u, v in list(G.edges()): edges = list(G.get_edge_data(u, v).values()) if len(edges) > 1: # Multiple edges exist resistances = [edge['weight'] for edge in edges] if any(R == 0 for R in resistances): # If any resistor is zero, equivalent resistance is zero R_new = 0 else: R_new = 1 / sum(1/R for R in resistances) # Parallel combination: 1/R_eq = 1/R1 + 1/R2 ... G.remove_edges_from(list(G.edges(u, v))) # Remove all parallel edges G.add_edge(u, v, weight=R_new) return True return False def compute_equivalent_resistance(G, source, sink): \"\"\"Compute equivalent resistance between source and sink.\"\"\" G = G.copy() # Work on a copy of the graph while len(G.nodes()) > 2 or G.number_of_edges() > 1: if reduce_series(G): continue if reduce_parallel(G): continue break # If no reduction was possible, exit the loop if G.has_edge(source, sink): return G[source][sink]['weight'] else: raise ValueError(\"No direct connection between source and sink after reduction.\") # Test the examples def test_circuits(): # Example 1: Simple Series G1 = nx.Graph() G1.add_edge('S', 'A', weight=2) G1.add_edge('A', 'T', weight=3) print(\"\\nExample 1 - Simple Series (2\u03a9 + 3\u03a9):\") R_eq1 = compute_equivalent_resistance(G1, 'S', 'T') print(f\"Equivalent Resistance = {R_eq1:.2f} \u03a9\") # Example 2: Simple Parallel G2 = nx.Graph() G2.add_edge('S', 'T', weight=4) G2.add_edge('S', 'T', weight=6) print(\"\\nExample 2 - Simple Parallel (4\u03a9 || 6\u03a9):\") R_eq2 = compute_equivalent_resistance(G2, 'S', 'T') print(f\"Equivalent Resistance = {R_eq2:.2f} \u03a9\") # Example 3: Nested Configuration G3 = nx.Graph() G3.add_edge('S', 'A', weight=2) G3.add_edge('A', 'B', weight=3) G3.add_edge('A', 'B', weight=6) G3.add_edge('B', 'T', weight=4) print(\"\\nExample 3 - Nested (2\u03a9 in series with (3\u03a9 || 6\u03a9) in series with 4\u03a9):\") R_eq3 = compute_equivalent_resistance(G3, 'S', 'T') print(f\"Equivalent Resistance = {R_eq3:.2f} \u03a9\") if __name__ == \"__main__\": test_circuits()","title":"Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-simple-series-2-3","text":"Equivalent Resistance = 5.00 \u03a9","title":"Example 1 - Simple Series (2\u03a9 + 3\u03a9):"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-simple-parallel-4-6","text":"Equivalent Resistance = 6.00 \u03a9","title":"Example 2 - Simple Parallel (4\u03a9 || 6\u03a9):"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-nested-2-in-series-with-3-6-in-series-with-4","text":"Equivalent Resistance = 12.00 \u03a9","title":"Example 3 - Nested (2\u03a9 in series with (3\u03a9 || 6\u03a9) in series with 4\u03a9):"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 - Exploring the Central Limit Theorem through Simulations \ud83d\udd37 Motivation: The Central Limit Theorem (CLT) is a cornerstone of probability and statistics. It states that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the population\u2019s original distribution. Simulations provide an intuitive and hands-on way to observe this phenomenon in action. \ud83d\udd37 Task: 1. Simulating Sampling Distributions: Select several types of population distributions: Uniform distribution Exponential distribution Binomial distribution For each distribution, generate a large dataset representing the population. 2. Sampling and Visualization: Randomly sample data from the population. Calculate the sample mean for different sample sizes (e.g., 5, 10, 30, 50). Repeat the process many times to generate the sampling distribution of the sample mean. Plot histograms of the sample means for each sample size. Observe convergence to the normal distribution as sample size increases. 3. Parameter Exploration: Investigate how: The shape of the original population distribution The sample size influence the rate of convergence to normality Highlight how population variance impacts the spread of the sampling distribution. 4. Practical Applications: Reflect on the importance of CLT in real-world contexts: Estimating population parameters Quality control in manufacturing Predicting outcomes in financial models \ud83d\udd37 Deliverables: A Markdown document and Python script or notebook implementing the simulations Plots illustrating the sampling distributions and their convergence to normality A short discussion on: The observed results How they align with theoretical expectations \ud83d\udd37 Hints and Resources: Use Python libraries: NumPy for random number generation Matplotlib or Seaborn for visualization Begin with simple populations (e.g., uniform or normal) Emphasize understanding of: Sample mean Variance Why CLT matters in real-world data analysis This task encourages you to explore the Central Limit Theorem through computational simulations, helping build strong conceptual and practical understanding in statistics.","title":"Problem 1 - Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1-exploring-the-central-limit-theorem-through-simulations","text":"","title":"Problem 1 - Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a cornerstone of probability and statistics. It states that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the population\u2019s original distribution. Simulations provide an intuitive and hands-on way to observe this phenomenon in action.","title":"\ud83d\udd37 Motivation:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task","text":"","title":"\ud83d\udd37 Task:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"Select several types of population distributions: Uniform distribution Exponential distribution Binomial distribution For each distribution, generate a large dataset representing the population.","title":"1. Simulating Sampling Distributions:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"Randomly sample data from the population. Calculate the sample mean for different sample sizes (e.g., 5, 10, 30, 50). Repeat the process many times to generate the sampling distribution of the sample mean. Plot histograms of the sample means for each sample size. Observe convergence to the normal distribution as sample size increases.","title":"2. Sampling and Visualization:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"Investigate how: The shape of the original population distribution The sample size influence the rate of convergence to normality Highlight how population variance impacts the spread of the sampling distribution.","title":"3. Parameter Exploration:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications","text":"Reflect on the importance of CLT in real-world contexts: Estimating population parameters Quality control in manufacturing Predicting outcomes in financial models","title":"4. Practical Applications:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#deliverables","text":"A Markdown document and Python script or notebook implementing the simulations Plots illustrating the sampling distributions and their convergence to normality A short discussion on: The observed results How they align with theoretical expectations","title":"\ud83d\udd37 Deliverables:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#hints-and-resources","text":"Use Python libraries: NumPy for random number generation Matplotlib or Seaborn for visualization Begin with simple populations (e.g., uniform or normal) Emphasize understanding of: Sample mean Variance Why CLT matters in real-world data analysis This task encourages you to explore the Central Limit Theorem through computational simulations, helping build strong conceptual and practical understanding in statistics.","title":"\ud83d\udd37 Hints and Resources:"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 - Estimating Pi using Monte Carlo Methods \ud83d\udd37 Motivation: Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One of the most elegant applications is estimating the value of \\(\\pi\\) through geometric probability. By randomly generating points and analyzing their positions relative to a geometric shape, we can approximate \\(\\pi\\) in an intuitive and visually engaging way. This problem connects fundamental concepts of probability , geometry , and numerical computation . It also provides a gateway to understand how randomness can be harnessed to solve complex problems in physics, finance, and computer science. \ud83d\udd37 Task: \ud83d\udd39 PART 1: Estimating \\(\\pi\\) Using a Circle 1. Theoretical Foundation: Explain how the ratio of points inside a circle to the total number of points in a square can be used to estimate \\(\\pi\\) . Derive the formula: [ \\pi \\approx 4 \\cdot \\left(\\frac{\\text{points inside circle}}{\\text{total points}}\\right) ] for a unit circle. 2. Simulation: Generate random points in a 2D square bounding a unit circle. Count the number of points falling inside the circle. Estimate \\(\\pi\\) based on this ratio. 3. Visualization: Create a plot showing the randomly generated points. Distinguish between those inside and outside the circle. 4. Analysis: Investigate how accuracy improves as the number of points increases. Discuss convergence rate and computational considerations. \ud83d\udd39 PART 2: Estimating \\(\\pi\\) Using Buffon\u2019s Needle 1. Theoretical Foundation: Describe Buffon\u2019s Needle problem: estimate \\(\\pi\\) based on the probability of a needle crossing parallel lines. Derive the formula: [ \\pi \\approx \\frac{2 \\cdot \\text{needle length} \\cdot \\text{number of throws}}{\\text{distance between lines} \\cdot \\text{number of crossings}} ] 2. Simulation: Simulate the random dropping of a needle on a plane with parallel lines. Count how many times the needle crosses a line. Estimate \\(\\pi\\) using the formula. 3. Visualization: Create a graphical representation of the simulation. Show needle positions relative to the lines. 4. Analysis: Explore how the number of drops affects accuracy. Compare convergence with the circle-based method. \ud83d\udd37 Deliverables: A Markdown document with: Clear explanations of both methods Discussion of theoretical foundations and results Python scripts/notebooks: Code for circle-based Monte Carlo simulation Code for Buffon\u2019s Needle simulation Graphical outputs: Plots of random points (circle method) Visualizations of needle positions (Buffon\u2019s method) Analysis: Tables/graphs showing convergence vs iterations Comparison of both methods in terms of accuracy & efficiency \ud83d\udd37 Hints and Resources: Use NumPy for random generation Use Matplotlib for visualizations Ensure uniform random point generation (for circle method) In Buffon\u2019s Needle: Pay attention to geometry: needle length vs distance between lines Start with small iteration counts, then increase for convergence","title":"Problem 2 - Estimating Pi using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2-estimating-pi-using-monte-carlo-methods","text":"","title":"Problem 2 - Estimating Pi using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One of the most elegant applications is estimating the value of \\(\\pi\\) through geometric probability. By randomly generating points and analyzing their positions relative to a geometric shape, we can approximate \\(\\pi\\) in an intuitive and visually engaging way. This problem connects fundamental concepts of probability , geometry , and numerical computation . It also provides a gateway to understand how randomness can be harnessed to solve complex problems in physics, finance, and computer science.","title":"\ud83d\udd37 Motivation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#task","text":"","title":"\ud83d\udd37 Task:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-pi-using-a-circle","text":"","title":"\ud83d\udd39 PART 1: Estimating \\(\\pi\\) Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"Explain how the ratio of points inside a circle to the total number of points in a square can be used to estimate \\(\\pi\\) . Derive the formula: [ \\pi \\approx 4 \\cdot \\left(\\frac{\\text{points inside circle}}{\\text{total points}}\\right) ] for a unit circle.","title":"1. Theoretical Foundation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"Generate random points in a 2D square bounding a unit circle. Count the number of points falling inside the circle. Estimate \\(\\pi\\) based on this ratio.","title":"2. Simulation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"Create a plot showing the randomly generated points. Distinguish between those inside and outside the circle.","title":"3. Visualization:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis","text":"Investigate how accuracy improves as the number of points increases. Discuss convergence rate and computational considerations.","title":"4. Analysis:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-pi-using-buffons-needle","text":"","title":"\ud83d\udd39 PART 2: Estimating \\(\\pi\\) Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"Describe Buffon\u2019s Needle problem: estimate \\(\\pi\\) based on the probability of a needle crossing parallel lines. Derive the formula: [ \\pi \\approx \\frac{2 \\cdot \\text{needle length} \\cdot \\text{number of throws}}{\\text{distance between lines} \\cdot \\text{number of crossings}} ]","title":"1. Theoretical Foundation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation_1","text":"Simulate the random dropping of a needle on a plane with parallel lines. Count how many times the needle crosses a line. Estimate \\(\\pi\\) using the formula.","title":"2. Simulation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization_1","text":"Create a graphical representation of the simulation. Show needle positions relative to the lines.","title":"3. Visualization:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis_1","text":"Explore how the number of drops affects accuracy. Compare convergence with the circle-based method.","title":"4. Analysis:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#deliverables","text":"A Markdown document with: Clear explanations of both methods Discussion of theoretical foundations and results Python scripts/notebooks: Code for circle-based Monte Carlo simulation Code for Buffon\u2019s Needle simulation Graphical outputs: Plots of random points (circle method) Visualizations of needle positions (Buffon\u2019s method) Analysis: Tables/graphs showing convergence vs iterations Comparison of both methods in terms of accuracy & efficiency","title":"\ud83d\udd37 Deliverables:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#hints-and-resources","text":"Use NumPy for random generation Use Matplotlib for visualizations Ensure uniform random point generation (for circle method) In Buffon\u2019s Needle: Pay attention to geometry: needle length vs distance between lines Start with small iteration counts, then increase for convergence","title":"\ud83d\udd37 Hints and Resources:"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 - Measuring Earth's Gravitational Acceleration with a Pendulum \ud83d\udd0d Motivation The acceleration \\( g \\) due to gravity is a fundamental constant that influences a wide range of physical phenomena. One classic method for determining \\( g \\) is through the oscillations of a simple pendulum, where the period depends on the local gravitational field. \ud83e\uddea Procedure 1. Materials: A string (~1\u20131.5 meters) A small weight (e.g., washer, keychain) Stopwatch (or phone timer) Ruler or measuring tape 2. Setup: Attach the weight and suspend the string. Measure pendulum length \\( L \\) from suspension point to center of mass. Estimate uncertainty in \\( L \\) as: \\[ \\Delta L = \\frac{\\text{Ruler Resolution}}{2} \\] 3. Data Collection: Pull pendulum to <15\u00b0 and release. Measure \\( T_{10} \\) for 10 full oscillations, 10 times. Compute: Mean time: \\( \\overline{T_{10}} \\) Standard deviation: \\( \\sigma_T \\) Uncertainty: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}}, \\quad n = 10 \\] \ud83e\uddee Calculations 1. Calculate the period: \\[ T = \\frac{\\overline{T_{10}}}{10}, \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} \\] 2. Determine g: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] 3. Propagate uncertainties: \\[ \\Delta g = g \\sqrt{ \\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\frac{\\Delta T}{T}\\right)^2 } \\] \ud83d\udcca Analysis Compare measured \\( g \\) with standard \\( 9.81 \\, m/s^2 \\) Discuss: Measurement resolution's effect on \\( \\Delta L \\) Timing variability and \\( \\Delta T \\) Assumptions & limitations \u2705 Deliverables Tabulated: \\( L \\) , \\( \\Delta L \\) , \\( T_{10} \\) , \\( \\overline{T_{10}} \\) , \\( \\sigma_T \\) , \\( \\Delta T \\) , \\( g \\) , \\( \\Delta g \\) Python script (.py) used for calculations and visualizations \u2705 Results and Analysis Measured Values: Quantity Symbol Value Pendulum Length \\( L \\) 1.00 m Uncertainty in \\( L \\) \\( \\Delta L \\) 0.005 m Mean Time for 10 Oscillations \\( \\overline{T}_{10} \\) 20.250 s Std Dev of \\( T_{10} \\) \\( \\sigma_T \\) 0.085 s Uncertainty in \\( T_{10} \\) \\( \\Delta T_{10} \\) 0.027 s Period \\( T \\) 2.025 s Uncertainty in \\( T \\) \\( \\Delta T \\) 0.003 s Calculated \\( g \\) \\( g \\) 9.63 m/s\u00b2 Uncertainty in \\( g \\) \\( \\Delta g \\) 0.05 m/s\u00b2 \ud83d\udcac Discussion Comparison with standard value: The calculated \\( g = 9.63 \\, \\text{m/s}^2 \\) is slightly lower than the accepted standard \\( 9.81 \\, \\text{m/s}^2 \\) , within experimental uncertainty. Effect of resolution \\( \\Delta L \\) : Small uncertainty in length slightly affects the precision but is relatively minimal. Timing variability \\( \\Delta T \\) : The most significant contributor to uncertainty arises from human reaction time during stopwatch usage. Experimental limitations: Manual timing, air resistance, and angle variations (<15\u00b0 assumed) may have introduced errors. \ud83d\udce6 Deliverables Summary \u2705 Python simulation in pendulum_measurement.py \u2705 Markdown documentation with formulas, procedure, and results \u2705 Quantitative uncertainty analysis and final discussion","title":"Problem 1 - Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1-measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Problem 1 - Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration \\( g \\) due to gravity is a fundamental constant that influences a wide range of physical phenomena. One classic method for determining \\( g \\) is through the oscillations of a simple pendulum, where the period depends on the local gravitational field.","title":"\ud83d\udd0d Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"\ud83e\uddea Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-materials","text":"A string (~1\u20131.5 meters) A small weight (e.g., washer, keychain) Stopwatch (or phone timer) Ruler or measuring tape","title":"1. Materials:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-setup","text":"Attach the weight and suspend the string. Measure pendulum length \\( L \\) from suspension point to center of mass. Estimate uncertainty in \\( L \\) as: \\[ \\Delta L = \\frac{\\text{Ruler Resolution}}{2} \\]","title":"2. Setup:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-data-collection","text":"Pull pendulum to <15\u00b0 and release. Measure \\( T_{10} \\) for 10 full oscillations, 10 times. Compute: Mean time: \\( \\overline{T_{10}} \\) Standard deviation: \\( \\sigma_T \\) Uncertainty: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}}, \\quad n = 10 \\]","title":"3. Data Collection:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"\ud83e\uddee Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-calculate-the-period","text":"\\[ T = \\frac{\\overline{T_{10}}}{10}, \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} \\]","title":"1. Calculate the period:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-determine-g","text":"\\[ g = \\frac{4\\pi^2 L}{T^2} \\]","title":"2. Determine g:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-propagate-uncertainties","text":"\\[ \\Delta g = g \\sqrt{ \\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\frac{\\Delta T}{T}\\right)^2 } \\]","title":"3. Propagate uncertainties:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"Compare measured \\( g \\) with standard \\( 9.81 \\, m/s^2 \\) Discuss: Measurement resolution's effect on \\( \\Delta L \\) Timing variability and \\( \\Delta T \\) Assumptions & limitations","title":"\ud83d\udcca Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#deliverables","text":"Tabulated: \\( L \\) , \\( \\Delta L \\) , \\( T_{10} \\) , \\( \\overline{T_{10}} \\) , \\( \\sigma_T \\) , \\( \\Delta T \\) , \\( g \\) , \\( \\Delta g \\) Python script (.py) used for calculations and visualizations","title":"\u2705 Deliverables"},{"location":"1%20Physics/7%20Measurements/Problem_1/#results-and-analysis","text":"Measured Values: Quantity Symbol Value Pendulum Length \\( L \\) 1.00 m Uncertainty in \\( L \\) \\( \\Delta L \\) 0.005 m Mean Time for 10 Oscillations \\( \\overline{T}_{10} \\) 20.250 s Std Dev of \\( T_{10} \\) \\( \\sigma_T \\) 0.085 s Uncertainty in \\( T_{10} \\) \\( \\Delta T_{10} \\) 0.027 s Period \\( T \\) 2.025 s Uncertainty in \\( T \\) \\( \\Delta T \\) 0.003 s Calculated \\( g \\) \\( g \\) 9.63 m/s\u00b2 Uncertainty in \\( g \\) \\( \\Delta g \\) 0.05 m/s\u00b2","title":"\u2705 Results and Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion","text":"Comparison with standard value: The calculated \\( g = 9.63 \\, \\text{m/s}^2 \\) is slightly lower than the accepted standard \\( 9.81 \\, \\text{m/s}^2 \\) , within experimental uncertainty. Effect of resolution \\( \\Delta L \\) : Small uncertainty in length slightly affects the precision but is relatively minimal. Timing variability \\( \\Delta T \\) : The most significant contributor to uncertainty arises from human reaction time during stopwatch usage. Experimental limitations: Manual timing, air resistance, and angle variations (<15\u00b0 assumed) may have introduced errors.","title":"\ud83d\udcac Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#deliverables-summary","text":"\u2705 Python simulation in pendulum_measurement.py \u2705 Markdown documentation with formulas, procedure, and results \u2705 Quantitative uncertainty analysis and final discussion","title":"\ud83d\udce6 Deliverables Summary"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}