{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Projectile motion describes the trajectory of an object under the influence of gravity, assuming no other forces (e.g., air resistance) act upon it. Let\u2019s derive the governing equations from first principles. 1.1 Deriving the Equations of Motion The motion can be split into horizontal (x) and vertical (y) components. Assume the projectile is launched from the origin \\((x_0, y_0) = (0, 0)\\) with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) from the horizontal. The acceleration due to gravity is \\(g\\) , acting downward. Initial velocities: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Accelerations: Horizontal: \\(a_x = 0\\) (no horizontal forces) Vertical: \\(a_y = -g\\) Using Newton\u2019s equations of motion, the position as a function of time \\(t\\) is: Horizontal: \\(x(t) = v_{0x} t = (v_0 \\cos\\theta) t\\) Vertical: \\(y(t) = v_{0y} t + \\frac{1}{2} a_y t^2 = (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2\\) 1.2 Time of Flight The projectile returns to the ground when \\(y(t) = 0\\) : \\[ (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2 = 0 \\] Factorizing: \\[ t \\left( v_0 \\sin\\theta - \\frac{1}{2} g t \\right) = 0 \\] Solutions: \\(t = 0\\) (launch) or \\(t = \\frac{2 v_0 \\sin\\theta}{g}\\) (landing). Thus, the time of flight \\(T\\) is: \\[ T = \\frac{2 v_0 \\sin\\theta}{g} \\] 1.3 Range Equation The horizontal range \\(R\\) is the distance traveled when \\(t = T\\) : \\[ R = v_{0x} T = (v_0 \\cos\\theta) \\cdot \\frac{2 v_0 \\sin\\theta}{g} \\] Using the trigonometric identity \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] This is the range as a function of the angle of projection \\(\\theta\\) . 1.4 Family of Solutions The range depends on free parameters: \\(v_0\\) : Initial velocity \\(g\\) : Gravitational acceleration \\(\\theta\\) : Angle of projection Varying these parameters generates a family of solutions. For instance, increasing \\(v_0\\) scales \\(R\\) quadratically, while \\(g\\) inversely affects \\(R\\) . 2. Analysis of the Range 2.1 Dependence on Angle \\(\\theta\\) The term \\(\\sin 2\\theta\\) dictates the angular dependence: At \\(\\theta = 0^\\circ\\) or \\(90^\\circ\\) , \\(\\sin 2\\theta = 0\\) , so \\(R = 0\\) . Maximum range occurs when \\(\\sin 2\\theta = 1\\) , i.e., \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) : \\[ R_{\\text{max}} = \\frac{v_0^2}{g} \\] Complementary angles (e.g., \\(30^\\circ\\) and \\(60^\\circ\\) ) yield the same range since \\(\\sin(180^\\circ - 2\\theta) = \\sin 2\\theta\\) . 2.2 Influence of Parameters Initial Velocity ( \\(v_0\\) ) : \\(R \\propto v_0^2\\) . Doubling \\(v_0\\) quadruples the range. Gravity ( \\(g\\) ) : \\(R \\propto \\frac{1}{g}\\) . On the Moon ( \\(g \\approx 1.62 \\, \\text{m/s}^2\\) ), the range is ~6 times larger than on Earth ( \\(g \\approx 9.81 \\, \\text{m/s}^2\\) ). 3. Practical Applications 3.1 Uneven Terrain For a launch height \\(h\\) , the vertical displacement becomes: $$ y(t) = h + (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2 $$ Set \\(y(t) = 0\\) to find the new time of flight: \\[ \\frac{1}{2} g t^2 - (v_0 \\sin\\theta) t - h = 0 \\] Solve the quadratic equation for \\(t\\) , then compute \\(R = (v_0 \\cos\\theta) t\\) . Max Range = 49.78 m at 39.0\u00b0 3.2 Air Resistance With drag ( \\(F_d = -k v\\) ), the equations become nonlinear: \\[ m \\frac{dv_x}{dt} = -k v_x, \\quad m \\frac{dv_y}{dt} = -mg - k v_y \\] Analytical solutions are complex, so numerical methods (e.g., Euler or Runge-Kutta) are typically used. 3.3 Real-World Examples Sports : Optimizing a basketball shot ( \\(\\theta \\approx 45^\\circ\\) ). Engineering : Artillery trajectories with wind and drag. Astrophysics : Planetary motion with adjusted \\(g\\) . 4. Implementation Below is a Python script to simulate and visualize the range versus angle. v0 = 10 m/s, Max Range at 45\u00b0 = 10.19 m v0 = 20 m/s, Max Range at 45\u00b0 = 40.77 m v0 = 30 m/s, Max Range at 45\u00b0 = 91.74 m","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion describes the trajectory of an object under the influence of gravity, assuming no other forces (e.g., air resistance) act upon it. Let\u2019s derive the governing equations from first principles.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-deriving-the-equations-of-motion","text":"The motion can be split into horizontal (x) and vertical (y) components. Assume the projectile is launched from the origin \\((x_0, y_0) = (0, 0)\\) with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) from the horizontal. The acceleration due to gravity is \\(g\\) , acting downward. Initial velocities: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Accelerations: Horizontal: \\(a_x = 0\\) (no horizontal forces) Vertical: \\(a_y = -g\\) Using Newton\u2019s equations of motion, the position as a function of time \\(t\\) is: Horizontal: \\(x(t) = v_{0x} t = (v_0 \\cos\\theta) t\\) Vertical: \\(y(t) = v_{0y} t + \\frac{1}{2} a_y t^2 = (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2\\)","title":"1.1 Deriving the Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"The projectile returns to the ground when \\(y(t) = 0\\) : \\[ (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2 = 0 \\] Factorizing: \\[ t \\left( v_0 \\sin\\theta - \\frac{1}{2} g t \\right) = 0 \\] Solutions: \\(t = 0\\) (launch) or \\(t = \\frac{2 v_0 \\sin\\theta}{g}\\) (landing). Thus, the time of flight \\(T\\) is: \\[ T = \\frac{2 v_0 \\sin\\theta}{g} \\]","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-range-equation","text":"The horizontal range \\(R\\) is the distance traveled when \\(t = T\\) : \\[ R = v_{0x} T = (v_0 \\cos\\theta) \\cdot \\frac{2 v_0 \\sin\\theta}{g} \\] Using the trigonometric identity \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] This is the range as a function of the angle of projection \\(\\theta\\) .","title":"1.3 Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-family-of-solutions","text":"The range depends on free parameters: \\(v_0\\) : Initial velocity \\(g\\) : Gravitational acceleration \\(\\theta\\) : Angle of projection Varying these parameters generates a family of solutions. For instance, increasing \\(v_0\\) scales \\(R\\) quadratically, while \\(g\\) inversely affects \\(R\\) .","title":"1.4 Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-dependence-on-angle-theta","text":"The term \\(\\sin 2\\theta\\) dictates the angular dependence: At \\(\\theta = 0^\\circ\\) or \\(90^\\circ\\) , \\(\\sin 2\\theta = 0\\) , so \\(R = 0\\) . Maximum range occurs when \\(\\sin 2\\theta = 1\\) , i.e., \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) : \\[ R_{\\text{max}} = \\frac{v_0^2}{g} \\] Complementary angles (e.g., \\(30^\\circ\\) and \\(60^\\circ\\) ) yield the same range since \\(\\sin(180^\\circ - 2\\theta) = \\sin 2\\theta\\) .","title":"2.1 Dependence on Angle \\(\\theta\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-influence-of-parameters","text":"Initial Velocity ( \\(v_0\\) ) : \\(R \\propto v_0^2\\) . Doubling \\(v_0\\) quadruples the range. Gravity ( \\(g\\) ) : \\(R \\propto \\frac{1}{g}\\) . On the Moon ( \\(g \\approx 1.62 \\, \\text{m/s}^2\\) ), the range is ~6 times larger than on Earth ( \\(g \\approx 9.81 \\, \\text{m/s}^2\\) ).","title":"2.2 Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-uneven-terrain","text":"For a launch height \\(h\\) , the vertical displacement becomes: $$ y(t) = h + (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2 $$ Set \\(y(t) = 0\\) to find the new time of flight: \\[ \\frac{1}{2} g t^2 - (v_0 \\sin\\theta) t - h = 0 \\] Solve the quadratic equation for \\(t\\) , then compute \\(R = (v_0 \\cos\\theta) t\\) . Max Range = 49.78 m at 39.0\u00b0","title":"3.1 Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-air-resistance","text":"With drag ( \\(F_d = -k v\\) ), the equations become nonlinear: \\[ m \\frac{dv_x}{dt} = -k v_x, \\quad m \\frac{dv_y}{dt} = -mg - k v_y \\] Analytical solutions are complex, so numerical methods (e.g., Euler or Runge-Kutta) are typically used.","title":"3.2 Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-real-world-examples","text":"Sports : Optimizing a basketball shot ( \\(\\theta \\approx 45^\\circ\\) ). Engineering : Artillery trajectories with wind and drag. Astrophysics : Planetary motion with adjusted \\(g\\) .","title":"3.3 Real-World Examples"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Below is a Python script to simulate and visualize the range versus angle. v0 = 10 m/s, Max Range at 45\u00b0 = 10.19 m v0 = 20 m/s, Max Range at 45\u00b0 = 40.77 m v0 = 30 m/s, Max Range at 45\u00b0 = 91.74 m","title":"4. Implementation"},{"location":"1%20Physics/2%20Gravity/%23%20Escape%20Velocities%20and%20Cosmic%20Velocitie/","text":"escape_velocities.py","title":"# Escape Velocities and Cosmic Velocitie"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius Introduction The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a fundamental principle of celestial mechanics. This relationship allows us to understand planetary motions and gravitational interactions on both local and cosmic scales. Kepler\u2019s Third Law states that for an object in a circular orbit around a massive central body: [ T^2 \\propto R^3 ] where: - \\(T\\) is the orbital period (time taken to complete one orbit) - \\(R\\) is the orbital radius (distance from the central body) This law is crucial for calculating planetary masses, satellite trajectories, and space missions. Mathematical Derivation Using Newton\u2019s Law of Gravitation: [ F = \\frac{G M m}{R^2} ] and equating it to the centripetal force required for circular motion: [ \\frac{G M m}{R^2} = \\frac{m v^2}{R} ] Solving for the velocity \\(v\\) : [ v = \\sqrt{\\frac{G M}{R}} ] Since the orbital period \\(T\\) is related to the velocity by: [ T = \\frac{2 \\pi R}{v} ] Substituting for \\(v\\) : [ T^2 = \\frac{4 \\pi^2 R^3}{G M} ] Thus, confirming Kepler\u2019s Third Law: [ T^2 \\propto R^3 ] Python Simulation The following Python script simulates circular orbits and verifies Kepler\u2019s Third Law numerically. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M_sun = 1.989e30 # Mass of the Sun (kg) # Define planets with their average orbital radii (m) and periods (s) planets = { \"Mercury\": (5.79e10, 7.60e6), \"Venus\": (1.08e11, 1.94e7), \"Earth\": (1.50e11, 3.15e7), \"Mars\": (2.28e11, 5.94e7), \"Jupiter\": (7.78e11, 3.74e8), \"Saturn\": (1.43e12, 9.29e8), \"Uranus\": (2.87e12, 2.65e9), \"Neptune\": (4.50e12, 5.20e9) } # Extract data for plotting radii = np.array([data[0] for data in planets.values()]) periods = np.array([data[1] for data in planets.values()]) # Verify Kepler\u2019s Third Law kepler_ratio = periods**2 / radii**3 # Plot results plt.figure(figsize=(8, 6)) plt.scatter(radii, periods**2, label=\"T^2 vs R^3 Data\", color='blue') plt.plot(radii, (4 * np.pi**2 / (G * M_sun)) * radii**3, linestyle='--', label=\"Kepler\u2019s Law Fit\", color='red') plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"Orbital Period Squared (s\u00b2)\") plt.title(\"Verification of Kepler\u2019s Third Law\") plt.legend() plt.grid() plt.show() Results and Analysis The simulation confirms that the square of the orbital period is proportional to the cube of the orbital radius. The scatter plot and theoretical curve demonstrate Kepler\u2019s Third Law in action. This relationship is fundamental for space missions, satellite deployment, and astrophysics. Understanding Kepler\u2019s laws helps scientists estimate planetary masses, satellite orbits, and even exoplanetary systems in distant galaxies.","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a fundamental principle of celestial mechanics. This relationship allows us to understand planetary motions and gravitational interactions on both local and cosmic scales. Kepler\u2019s Third Law states that for an object in a circular orbit around a massive central body: [ T^2 \\propto R^3 ] where: - \\(T\\) is the orbital period (time taken to complete one orbit) - \\(R\\) is the orbital radius (distance from the central body) This law is crucial for calculating planetary masses, satellite trajectories, and space missions.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mathematical-derivation","text":"Using Newton\u2019s Law of Gravitation: [ F = \\frac{G M m}{R^2} ] and equating it to the centripetal force required for circular motion: [ \\frac{G M m}{R^2} = \\frac{m v^2}{R} ] Solving for the velocity \\(v\\) : [ v = \\sqrt{\\frac{G M}{R}} ] Since the orbital period \\(T\\) is related to the velocity by: [ T = \\frac{2 \\pi R}{v} ] Substituting for \\(v\\) : [ T^2 = \\frac{4 \\pi^2 R^3}{G M} ] Thus, confirming Kepler\u2019s Third Law: [ T^2 \\propto R^3 ]","title":"Mathematical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation","text":"The following Python script simulates circular orbits and verifies Kepler\u2019s Third Law numerically. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M_sun = 1.989e30 # Mass of the Sun (kg) # Define planets with their average orbital radii (m) and periods (s) planets = { \"Mercury\": (5.79e10, 7.60e6), \"Venus\": (1.08e11, 1.94e7), \"Earth\": (1.50e11, 3.15e7), \"Mars\": (2.28e11, 5.94e7), \"Jupiter\": (7.78e11, 3.74e8), \"Saturn\": (1.43e12, 9.29e8), \"Uranus\": (2.87e12, 2.65e9), \"Neptune\": (4.50e12, 5.20e9) } # Extract data for plotting radii = np.array([data[0] for data in planets.values()]) periods = np.array([data[1] for data in planets.values()]) # Verify Kepler\u2019s Third Law kepler_ratio = periods**2 / radii**3 # Plot results plt.figure(figsize=(8, 6)) plt.scatter(radii, periods**2, label=\"T^2 vs R^3 Data\", color='blue') plt.plot(radii, (4 * np.pi**2 / (G * M_sun)) * radii**3, linestyle='--', label=\"Kepler\u2019s Law Fit\", color='red') plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"Orbital Period Squared (s\u00b2)\") plt.title(\"Verification of Kepler\u2019s Third Law\") plt.legend() plt.grid() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#results-and-analysis","text":"The simulation confirms that the square of the orbital period is proportional to the cube of the orbital radius. The scatter plot and theoretical curve demonstrate Kepler\u2019s Third Law in action. This relationship is fundamental for space missions, satellite deployment, and astrophysics. Understanding Kepler\u2019s laws helps scientists estimate planetary masses, satellite orbits, and even exoplanetary systems in distant galaxies.","title":"Results and Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2# Escape Velocities and Cosmic Velocities Introduction Escape velocity is a crucial concept in understanding how objects can overcome the gravitational pull of celestial bodies. The first, second, and third cosmic velocities define the minimum speeds required to: - Orbit a planet (first cosmic velocity) - Escape a planet\u2019s gravity (second cosmic velocity) - Escape a star system (third cosmic velocity) These velocities are essential for satellite launches, planetary exploration, and interstellar travel. Mathematical Derivation First Cosmic Velocity (Orbital Velocity) : [ v_1 = \\sqrt{\\frac{G M}{R}} ] where: \\( G \\) is the gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3/kg/s\u00b2) \\( M \\) is the mass of the celestial body \\( R \\) is the radius of the celestial body Second Cosmic Velocity (Escape Velocity) : [ v_2 = \\sqrt{2 \\frac{G M}{R}} ] This is derived from energy conservation, requiring an object\u2019s kinetic energy to counteract gravitational potential energy. Third Cosmic Velocity (Solar Escape Velocity) : [ v_3 = \\sqrt{2 \\frac{G M_{sun}}{d} + v_2^2} ] This velocity allows an object to escape from the gravitational influence of a star (like the Sun) considering its initial velocity from a planetary surface. Python Simulation The following Python script calculates and visualizes the cosmic velocities for Earth, Mars, and Jupiter: import numpy as np import matplotlib.pyplot as plt # Universal Gravitational Constant (m^3 kg^-1 s^-2) G = 6.67430e-11 # Dictionary of celestial bodies with mass (kg) and radius (m) celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.3895e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } def escape_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) def orbital_velocity(mass, radius): return np.sqrt(G * mass / radius) def solar_escape_velocity(mass, radius, sun_mass, sun_distance): return np.sqrt(2 * G * sun_mass / sun_distance + escape_velocity(mass, radius)**2) # Compute velocities velocities = {} for planet, data in celestial_bodies.items(): ve = escape_velocity(data[\"mass\"], data[\"radius\"]) # Second cosmic velocity v1 = orbital_velocity(data[\"mass\"], data[\"radius\"]) # First cosmic velocity v3 = solar_escape_velocity(data[\"mass\"], data[\"radius\"], 1.989e30, 1.5e11) # Third cosmic velocity (approx.) velocities[planet] = {\"v1\": v1, \"v2\": ve, \"v3\": v3} # Plot results fig, ax = plt.subplots() planets = list(velocities.keys()) v1_values = [velocities[p][\"v1\"] for p in planets] v2_values = [velocities[p][\"v2\"] for p in planets] v3_values = [velocities[p][\"v3\"] for p in planets] ax.bar(planets, v1_values, label=\"First Cosmic Velocity\") ax.bar(planets, v2_values, bottom=v1_values, label=\"Second Cosmic Velocity\") ax.bar(planets, v3_values, bottom=np.array(v1_values) + np.array(v2_values), label=\"Third Cosmic Velocity\") ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"Comparison of Cosmic Velocities\") ax.legend() plt.show() Results and Analysis The first cosmic velocity is the smallest, allowing objects to remain in orbit. The second cosmic velocity is higher, enabling objects to leave planetary gravity. The third cosmic velocity is the highest, required to exit a star system. These velocities play a vital role in space missions, from launching satellites to planning interstellar travel.","title":"Problem 2# Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"Problem 2# Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"Escape velocity is a crucial concept in understanding how objects can overcome the gravitational pull of celestial bodies. The first, second, and third cosmic velocities define the minimum speeds required to: - Orbit a planet (first cosmic velocity) - Escape a planet\u2019s gravity (second cosmic velocity) - Escape a star system (third cosmic velocity) These velocities are essential for satellite launches, planetary exploration, and interstellar travel.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivation","text":"First Cosmic Velocity (Orbital Velocity) : [ v_1 = \\sqrt{\\frac{G M}{R}} ] where: \\( G \\) is the gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3/kg/s\u00b2) \\( M \\) is the mass of the celestial body \\( R \\) is the radius of the celestial body Second Cosmic Velocity (Escape Velocity) : [ v_2 = \\sqrt{2 \\frac{G M}{R}} ] This is derived from energy conservation, requiring an object\u2019s kinetic energy to counteract gravitational potential energy. Third Cosmic Velocity (Solar Escape Velocity) : [ v_3 = \\sqrt{2 \\frac{G M_{sun}}{d} + v_2^2} ] This velocity allows an object to escape from the gravitational influence of a star (like the Sun) considering its initial velocity from a planetary surface.","title":"Mathematical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation","text":"The following Python script calculates and visualizes the cosmic velocities for Earth, Mars, and Jupiter: import numpy as np import matplotlib.pyplot as plt # Universal Gravitational Constant (m^3 kg^-1 s^-2) G = 6.67430e-11 # Dictionary of celestial bodies with mass (kg) and radius (m) celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.3895e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } def escape_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) def orbital_velocity(mass, radius): return np.sqrt(G * mass / radius) def solar_escape_velocity(mass, radius, sun_mass, sun_distance): return np.sqrt(2 * G * sun_mass / sun_distance + escape_velocity(mass, radius)**2) # Compute velocities velocities = {} for planet, data in celestial_bodies.items(): ve = escape_velocity(data[\"mass\"], data[\"radius\"]) # Second cosmic velocity v1 = orbital_velocity(data[\"mass\"], data[\"radius\"]) # First cosmic velocity v3 = solar_escape_velocity(data[\"mass\"], data[\"radius\"], 1.989e30, 1.5e11) # Third cosmic velocity (approx.) velocities[planet] = {\"v1\": v1, \"v2\": ve, \"v3\": v3} # Plot results fig, ax = plt.subplots() planets = list(velocities.keys()) v1_values = [velocities[p][\"v1\"] for p in planets] v2_values = [velocities[p][\"v2\"] for p in planets] v3_values = [velocities[p][\"v3\"] for p in planets] ax.bar(planets, v1_values, label=\"First Cosmic Velocity\") ax.bar(planets, v2_values, bottom=v1_values, label=\"Second Cosmic Velocity\") ax.bar(planets, v3_values, bottom=np.array(v1_values) + np.array(v2_values), label=\"Third Cosmic Velocity\") ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"Comparison of Cosmic Velocities\") ax.legend() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#results-and-analysis","text":"The first cosmic velocity is the smallest, allowing objects to remain in orbit. The second cosmic velocity is higher, enabling objects to leave planetary gravity. The third cosmic velocity is the highest, required to exit a star system. These velocities play a vital role in space missions, from launching satellites to planning interstellar travel.","title":"Results and Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Introduction When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Orbital Mechanics and Possible Trajectories An object released near Earth can follow different types of trajectories based on its velocity and altitude: - Elliptical Orbit: If the velocity is below escape velocity but high enough, the object remains in orbit. - Parabolic Trajectory: If the velocity is exactly the escape velocity, the object follows a parabolic path and escapes Earth's gravity. - Hyperbolic Trajectory: If the velocity exceeds escape velocity, the object follows a hyperbolic trajectory and moves away from Earth indefinitely. - Suborbital (Ballistic) Trajectory: If the velocity is low, the object will re-enter Earth's atmosphere and eventually impact the surface. Mathematical Model Newton\u2019s Law of Gravitation governs the motion of the payload: [ F = \\frac{G M m}{r^2} ] where: - \\( G \\) is the gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3/kg/s\u00b2) - \\( M \\) is the mass of Earth (5.972 \u00d7 10\u00b2\u2074 kg) - \\( m \\) is the mass of the payload - \\( r \\) is the distance from the center of the Earth Using Newton\u2019s second law, we derive the equations of motion for numerical simulation. Python Simulation The following Python script numerically simulates the trajectory of a payload released near Earth, considering different initial velocities. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) # Equations of Motion def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, ax, vy, ay] # Initial Conditions altitude = 400000 # 400 km above Earth's surface initial_speed = 7500 # m/s (adjust to simulate different trajectories) angle = np.radians(45) # Launch angle x0, y0 = R_earth + altitude, 0 vx0, vy0 = initial_speed * np.cos(angle), initial_speed * np.sin(angle) # Time Span t_span = (0, 10000) t_eval = np.linspace(0, 10000, 1000) # Solve Differential Equations sol = solve_ivp(equations, t_span, [x0, vx0, y0, vy0], t_eval=t_eval, method='RK45') # Extract Results x_trajectory = sol.y[0] y_trajectory = sol.y[2] # Plot Trajectory fig, ax = plt.subplots(figsize=(6, 6)) ax.plot(x_trajectory, y_trajectory, label='Payload Trajectory') # Draw Earth earth = plt.Circle((0, 0), R_earth, color='blue', fill=True, alpha=0.3, label='Earth') ax.add_patch(earth) ax.set_xlim(-2*R_earth, 2*R_earth) ax.set_ylim(-2*R_earth, 2*R_earth) ax.set_xlabel(\"x position (m)\") ax.set_ylabel(\"y position (m)\") ax.set_title(\"Payload Trajectory near Earth\") ax.legend() ax.set_aspect('equal') plt.show() Results and Analysis If the initial velocity is below orbital speed, the payload follows a ballistic trajectory and falls back to Earth. If the initial velocity reaches orbital speed, the payload will follow an elliptical orbit. If the velocity is at escape speed, the payload follows a parabolic trajectory. If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and leaves Earth's gravitational influence. These findings are critical for space mission planning, satellite deployment, and planetary exploration.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#introduction","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-mechanics-and-possible-trajectories","text":"An object released near Earth can follow different types of trajectories based on its velocity and altitude: - Elliptical Orbit: If the velocity is below escape velocity but high enough, the object remains in orbit. - Parabolic Trajectory: If the velocity is exactly the escape velocity, the object follows a parabolic path and escapes Earth's gravity. - Hyperbolic Trajectory: If the velocity exceeds escape velocity, the object follows a hyperbolic trajectory and moves away from Earth indefinitely. - Suborbital (Ballistic) Trajectory: If the velocity is low, the object will re-enter Earth's atmosphere and eventually impact the surface.","title":"Orbital Mechanics and Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#mathematical-model","text":"Newton\u2019s Law of Gravitation governs the motion of the payload: [ F = \\frac{G M m}{r^2} ] where: - \\( G \\) is the gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3/kg/s\u00b2) - \\( M \\) is the mass of Earth (5.972 \u00d7 10\u00b2\u2074 kg) - \\( m \\) is the mass of the payload - \\( r \\) is the distance from the center of the Earth Using Newton\u2019s second law, we derive the equations of motion for numerical simulation.","title":"Mathematical Model"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation","text":"The following Python script numerically simulates the trajectory of a payload released near Earth, considering different initial velocities. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) # Equations of Motion def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, ax, vy, ay] # Initial Conditions altitude = 400000 # 400 km above Earth's surface initial_speed = 7500 # m/s (adjust to simulate different trajectories) angle = np.radians(45) # Launch angle x0, y0 = R_earth + altitude, 0 vx0, vy0 = initial_speed * np.cos(angle), initial_speed * np.sin(angle) # Time Span t_span = (0, 10000) t_eval = np.linspace(0, 10000, 1000) # Solve Differential Equations sol = solve_ivp(equations, t_span, [x0, vx0, y0, vy0], t_eval=t_eval, method='RK45') # Extract Results x_trajectory = sol.y[0] y_trajectory = sol.y[2] # Plot Trajectory fig, ax = plt.subplots(figsize=(6, 6)) ax.plot(x_trajectory, y_trajectory, label='Payload Trajectory') # Draw Earth earth = plt.Circle((0, 0), R_earth, color='blue', fill=True, alpha=0.3, label='Earth') ax.add_patch(earth) ax.set_xlim(-2*R_earth, 2*R_earth) ax.set_ylim(-2*R_earth, 2*R_earth) ax.set_xlabel(\"x position (m)\") ax.set_ylabel(\"y position (m)\") ax.set_title(\"Payload Trajectory near Earth\") ax.legend() ax.set_aspect('equal') plt.show()","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#results-and-analysis","text":"If the initial velocity is below orbital speed, the payload follows a ballistic trajectory and falls back to Earth. If the initial velocity reaches orbital speed, the payload will follow an elliptical orbit. If the velocity is at escape speed, the payload follows a parabolic trajectory. If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and leaves Earth's gravitational influence. These findings are critical for space mission planning, satellite deployment, and planetary exploration.","title":"Results and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 - Interference Patterns on a Water Surface \ud83d\udd37 Motivation: Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications. \ud83d\udd37 Task: A circular wave on the water surface, emanating from a point source located at \\((x_0, y_0)\\) , can be described by the Single Disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: - \\(\\eta(x, y, t)\\) = Displacement of the water surface at point \\((x, y)\\) and time \\(t\\) - \\(A\\) = Amplitude - \\(k = \\frac{2\\pi}{\\lambda}\\) = Wave number, related to wavelength \\(\\lambda\\) - \\(\\omega = 2\\pi f\\) = Angular frequency, related to frequency \\(f\\) - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) = Distance to source - \\(\\phi\\) = Initial phase \ud83d\udd37 Problem Statement: Analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. \ud83d\udd37 Steps to Follow: Select a Regular Polygon: Choose a regular polygon (e.g., equilateral triangle, square, pentagon). Position the Sources: Place point wave sources at the vertices of the selected polygon. Wave Equations: Write wave equations for each source, considering their positions. Superposition of Waves: [ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) ] where \\(N\\) = number of sources (polygon vertices) Analyze Interference Patterns: Examine \\(\\eta_{\\text{sum}}(x, y, t)\\) over time and space. Identify: Constructive interference (amplification) Destructive interference (cancellation) Visualization: Graphically represent wave patterns using simulations. \ud83d\udd37 Considerations: All sources emit waves with same amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) Waves are coherent , maintaining constant phase difference Visualization tools like Python + Matplotlib are recommended \ud83d\udd37 Deliverables: A Markdown document with embedded Python script / notebook A clear explanation of interference patterns for your chosen polygon Graphical results showing constructive & destructive regions","title":"Problem 1 - Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1-interference-patterns-on-a-water-surface","text":"","title":"Problem 1 - Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications.","title":"\ud83d\udd37 Motivation:"},{"location":"1%20Physics/3%20Waves/Problem_1/#task","text":"A circular wave on the water surface, emanating from a point source located at \\((x_0, y_0)\\) , can be described by the Single Disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: - \\(\\eta(x, y, t)\\) = Displacement of the water surface at point \\((x, y)\\) and time \\(t\\) - \\(A\\) = Amplitude - \\(k = \\frac{2\\pi}{\\lambda}\\) = Wave number, related to wavelength \\(\\lambda\\) - \\(\\omega = 2\\pi f\\) = Angular frequency, related to frequency \\(f\\) - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) = Distance to source - \\(\\phi\\) = Initial phase","title":"\ud83d\udd37 Task:"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"Analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon.","title":"\ud83d\udd37 Problem Statement:"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"Select a Regular Polygon: Choose a regular polygon (e.g., equilateral triangle, square, pentagon). Position the Sources: Place point wave sources at the vertices of the selected polygon. Wave Equations: Write wave equations for each source, considering their positions. Superposition of Waves: [ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) ] where \\(N\\) = number of sources (polygon vertices) Analyze Interference Patterns: Examine \\(\\eta_{\\text{sum}}(x, y, t)\\) over time and space. Identify: Constructive interference (amplification) Destructive interference (cancellation) Visualization: Graphically represent wave patterns using simulations.","title":"\ud83d\udd37 Steps to Follow:"},{"location":"1%20Physics/3%20Waves/Problem_1/#considerations","text":"All sources emit waves with same amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) Waves are coherent , maintaining constant phase difference Visualization tools like Python + Matplotlib are recommended","title":"\ud83d\udd37 Considerations:"},{"location":"1%20Physics/3%20Waves/Problem_1/#deliverables","text":"A Markdown document with embedded Python script / notebook A clear explanation of interference patterns for your chosen polygon Graphical results showing constructive & destructive regions","title":"\ud83d\udd37 Deliverables:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 - Simulating the Effects of the Lorentz Force \ud83d\udd37 Motivation: The Lorentz force, expressed as: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. By focusing on simulations, we can explore practical applications and visualize the complex trajectories that arise due to this force. \ud83d\udd37 Task: 1. Exploration of Applications: Identify systems where the Lorentz force plays a key role (e.g., particle accelerators, mass spectrometers, plasma confinement) Discuss the relevance of electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields in controlling the motion of charged particles. 2. Simulating Particle Motion: Implement a simulation to compute and visualize the trajectory of a charged particle under: A uniform magnetic field Combined uniform electric and magnetic fields Crossed electric and magnetic fields Simulate the particle\u2019s circular, helical, or drift motion based on initial conditions and field configurations. 3. Parameter Exploration: Allow variations in: Field strengths ( \\(\\mathbf{E}, \\mathbf{B}\\) ) Initial particle velocity ( \\(\\mathbf{v}\\) ) Charge and mass of the particle ( \\(q, m\\) ) Observe how these parameters influence the trajectory. 4. Visualization: Create clear, labeled plots showing the particle\u2019s path in 2D and 3D for different field configurations. Highlight physical phenomena such as Larmor radius and drift velocity . \ud83d\udd37 Deliverables: A Markdown document with Python script or notebook implementing the simulations Visualizations of particle trajectories for the specified field configurations A discussion on how the results relate to practical systems, such as cyclotrons or magnetic traps \ud83d\udd37 Hints and Resources: Use numerical methods like Euler or Runge-Kutta to solve motion equations Employ NumPy and Matplotlib in Python Start with simple cases (e.g., uniform magnetic field) then move to crossed-field setups","title":"Problem 1 - Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1-simulating-the-effects-of-the-lorentz-force","text":"","title":"Problem 1 - Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force, expressed as: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. By focusing on simulations, we can explore practical applications and visualize the complex trajectories that arise due to this force.","title":"\ud83d\udd37 Motivation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task","text":"","title":"\ud83d\udd37 Task:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"Identify systems where the Lorentz force plays a key role (e.g., particle accelerators, mass spectrometers, plasma confinement) Discuss the relevance of electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields in controlling the motion of charged particles.","title":"1. Exploration of Applications:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"Implement a simulation to compute and visualize the trajectory of a charged particle under: A uniform magnetic field Combined uniform electric and magnetic fields Crossed electric and magnetic fields Simulate the particle\u2019s circular, helical, or drift motion based on initial conditions and field configurations.","title":"2. Simulating Particle Motion:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"Allow variations in: Field strengths ( \\(\\mathbf{E}, \\mathbf{B}\\) ) Initial particle velocity ( \\(\\mathbf{v}\\) ) Charge and mass of the particle ( \\(q, m\\) ) Observe how these parameters influence the trajectory.","title":"3. Parameter Exploration:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"Create clear, labeled plots showing the particle\u2019s path in 2D and 3D for different field configurations. Highlight physical phenomena such as Larmor radius and drift velocity .","title":"4. Visualization:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables","text":"A Markdown document with Python script or notebook implementing the simulations Visualizations of particle trajectories for the specified field configurations A discussion on how the results relate to practical systems, such as cyclotrons or magnetic traps","title":"\ud83d\udd37 Deliverables:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#hints-and-resources","text":"Use numerical methods like Euler or Runge-Kutta to solve motion equations Employ NumPy and Matplotlib in Python Start with simple cases (e.g., uniform magnetic field) then move to crossed-field setups","title":"\ud83d\udd37 Hints and Resources:"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 - Equivalent Resistance Using Graph Theory \ud83d\udd37 Motivation: Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a powerful alternative: By representing a circuit as a graph\u2014where nodes correspond to junctions and edges represent resistors (with weights as resistance values)\u2014we can systematically simplify even the most intricate networks. This method enables: - Streamlined calculations - Algorithmic automation for circuit solvers - Applications in optimization, simulation, and network design Studying equivalent resistance through graph theory not only has practical value, but also deepens our understanding of the interplay between electrical and mathematical systems. \ud83d\udd37 Task Options: Option 1: Simplified Task \u2013 Algorithm Description Describe the algorithm for calculating equivalent resistance using graph theory Provide pseudocode that: Identifies series and parallel connections Iteratively reduces the graph to a single equivalent resistance Explains how nested combinations are handled Option 2: Advanced Task \u2013 Full Implementation Implement the algorithm in any programming language (e.g., Python) The implementation should: - Accept a circuit graph as input - Handle arbitrary resistor configurations including nested series/parallel - Output the final equivalent resistance - Be tested with multiple examples: - Simple combinations - Nested setups - Complex cyclic graphs \ud83d\udd37 Deliverables: A detailed pseudocode (preferably a working implementation ) Description of how your solution handles: Complex circuit topologies At least three test cases A brief analysis on: Algorithm efficiency Potential improvements \ud83d\udd37 Hints and Resources: Use iterative graph simplification : Detect linear chains \u2192 series reduction Identify cycles \u2192 parallel reduction Consider libraries such as: networkx (Python) for graph manipulation Algorithms to consider: DFS (Depth-First Search) Other traversal techniques for pattern detection Choose the task that matches your comfort level, but ensure your solution is well-structured and clear.","title":"Problem 1 - Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1-equivalent-resistance-using-graph-theory","text":"","title":"Problem 1 - Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a powerful alternative: By representing a circuit as a graph\u2014where nodes correspond to junctions and edges represent resistors (with weights as resistance values)\u2014we can systematically simplify even the most intricate networks. This method enables: - Streamlined calculations - Algorithmic automation for circuit solvers - Applications in optimization, simulation, and network design Studying equivalent resistance through graph theory not only has practical value, but also deepens our understanding of the interplay between electrical and mathematical systems.","title":"\ud83d\udd37 Motivation:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-options","text":"","title":"\ud83d\udd37 Task Options:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-1-simplified-task-algorithm-description","text":"Describe the algorithm for calculating equivalent resistance using graph theory Provide pseudocode that: Identifies series and parallel connections Iteratively reduces the graph to a single equivalent resistance Explains how nested combinations are handled","title":"Option 1: Simplified Task \u2013 Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-2-advanced-task-full-implementation","text":"Implement the algorithm in any programming language (e.g., Python) The implementation should: - Accept a circuit graph as input - Handle arbitrary resistor configurations including nested series/parallel - Output the final equivalent resistance - Be tested with multiple examples: - Simple combinations - Nested setups - Complex cyclic graphs","title":"Option 2: Advanced Task \u2013 Full Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#deliverables","text":"A detailed pseudocode (preferably a working implementation ) Description of how your solution handles: Complex circuit topologies At least three test cases A brief analysis on: Algorithm efficiency Potential improvements","title":"\ud83d\udd37 Deliverables:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#hints-and-resources","text":"Use iterative graph simplification : Detect linear chains \u2192 series reduction Identify cycles \u2192 parallel reduction Consider libraries such as: networkx (Python) for graph manipulation Algorithms to consider: DFS (Depth-First Search) Other traversal techniques for pattern detection Choose the task that matches your comfort level, but ensure your solution is well-structured and clear.","title":"\ud83d\udd37 Hints and Resources:"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 - Exploring the Central Limit Theorem through Simulations \ud83d\udd37 Motivation: The Central Limit Theorem (CLT) is a cornerstone of probability and statistics. It states that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the population\u2019s original distribution. Simulations provide an intuitive and hands-on way to observe this phenomenon in action. \ud83d\udd37 Task: 1. Simulating Sampling Distributions: Select several types of population distributions: Uniform distribution Exponential distribution Binomial distribution For each distribution, generate a large dataset representing the population. 2. Sampling and Visualization: Randomly sample data from the population. Calculate the sample mean for different sample sizes (e.g., 5, 10, 30, 50). Repeat the process many times to generate the sampling distribution of the sample mean. Plot histograms of the sample means for each sample size. Observe convergence to the normal distribution as sample size increases. 3. Parameter Exploration: Investigate how: The shape of the original population distribution The sample size influence the rate of convergence to normality Highlight how population variance impacts the spread of the sampling distribution. 4. Practical Applications: Reflect on the importance of CLT in real-world contexts: Estimating population parameters Quality control in manufacturing Predicting outcomes in financial models \ud83d\udd37 Deliverables: A Markdown document and Python script or notebook implementing the simulations Plots illustrating the sampling distributions and their convergence to normality A short discussion on: The observed results How they align with theoretical expectations \ud83d\udd37 Hints and Resources: Use Python libraries: NumPy for random number generation Matplotlib or Seaborn for visualization Begin with simple populations (e.g., uniform or normal) Emphasize understanding of: Sample mean Variance Why CLT matters in real-world data analysis This task encourages you to explore the Central Limit Theorem through computational simulations, helping build strong conceptual and practical understanding in statistics.","title":"Problem 1 - Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1-exploring-the-central-limit-theorem-through-simulations","text":"","title":"Problem 1 - Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a cornerstone of probability and statistics. It states that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the population\u2019s original distribution. Simulations provide an intuitive and hands-on way to observe this phenomenon in action.","title":"\ud83d\udd37 Motivation:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task","text":"","title":"\ud83d\udd37 Task:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"Select several types of population distributions: Uniform distribution Exponential distribution Binomial distribution For each distribution, generate a large dataset representing the population.","title":"1. Simulating Sampling Distributions:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"Randomly sample data from the population. Calculate the sample mean for different sample sizes (e.g., 5, 10, 30, 50). Repeat the process many times to generate the sampling distribution of the sample mean. Plot histograms of the sample means for each sample size. Observe convergence to the normal distribution as sample size increases.","title":"2. Sampling and Visualization:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"Investigate how: The shape of the original population distribution The sample size influence the rate of convergence to normality Highlight how population variance impacts the spread of the sampling distribution.","title":"3. Parameter Exploration:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications","text":"Reflect on the importance of CLT in real-world contexts: Estimating population parameters Quality control in manufacturing Predicting outcomes in financial models","title":"4. Practical Applications:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#deliverables","text":"A Markdown document and Python script or notebook implementing the simulations Plots illustrating the sampling distributions and their convergence to normality A short discussion on: The observed results How they align with theoretical expectations","title":"\ud83d\udd37 Deliverables:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#hints-and-resources","text":"Use Python libraries: NumPy for random number generation Matplotlib or Seaborn for visualization Begin with simple populations (e.g., uniform or normal) Emphasize understanding of: Sample mean Variance Why CLT matters in real-world data analysis This task encourages you to explore the Central Limit Theorem through computational simulations, helping build strong conceptual and practical understanding in statistics.","title":"\ud83d\udd37 Hints and Resources:"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 - Estimating Pi using Monte Carlo Methods \ud83d\udd37 Motivation: Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One of the most elegant applications is estimating the value of \\(\\pi\\) through geometric probability. By randomly generating points and analyzing their positions relative to a geometric shape, we can approximate \\(\\pi\\) in an intuitive and visually engaging way. This problem connects fundamental concepts of probability , geometry , and numerical computation . It also provides a gateway to understand how randomness can be harnessed to solve complex problems in physics, finance, and computer science. \ud83d\udd37 Task: \ud83d\udd39 PART 1: Estimating \\(\\pi\\) Using a Circle 1. Theoretical Foundation: Explain how the ratio of points inside a circle to the total number of points in a square can be used to estimate \\(\\pi\\) . Derive the formula: [ \\pi \\approx 4 \\cdot \\left(\\frac{\\text{points inside circle}}{\\text{total points}}\\right) ] for a unit circle. 2. Simulation: Generate random points in a 2D square bounding a unit circle. Count the number of points falling inside the circle. Estimate \\(\\pi\\) based on this ratio. 3. Visualization: Create a plot showing the randomly generated points. Distinguish between those inside and outside the circle. 4. Analysis: Investigate how accuracy improves as the number of points increases. Discuss convergence rate and computational considerations. \ud83d\udd39 PART 2: Estimating \\(\\pi\\) Using Buffon\u2019s Needle 1. Theoretical Foundation: Describe Buffon\u2019s Needle problem: estimate \\(\\pi\\) based on the probability of a needle crossing parallel lines. Derive the formula: [ \\pi \\approx \\frac{2 \\cdot \\text{needle length} \\cdot \\text{number of throws}}{\\text{distance between lines} \\cdot \\text{number of crossings}} ] 2. Simulation: Simulate the random dropping of a needle on a plane with parallel lines. Count how many times the needle crosses a line. Estimate \\(\\pi\\) using the formula. 3. Visualization: Create a graphical representation of the simulation. Show needle positions relative to the lines. 4. Analysis: Explore how the number of drops affects accuracy. Compare convergence with the circle-based method. \ud83d\udd37 Deliverables: A Markdown document with: Clear explanations of both methods Discussion of theoretical foundations and results Python scripts/notebooks: Code for circle-based Monte Carlo simulation Code for Buffon\u2019s Needle simulation Graphical outputs: Plots of random points (circle method) Visualizations of needle positions (Buffon\u2019s method) Analysis: Tables/graphs showing convergence vs iterations Comparison of both methods in terms of accuracy & efficiency \ud83d\udd37 Hints and Resources: Use NumPy for random generation Use Matplotlib for visualizations Ensure uniform random point generation (for circle method) In Buffon\u2019s Needle: Pay attention to geometry: needle length vs distance between lines Start with small iteration counts, then increase for convergence","title":"Problem 2 - Estimating Pi using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2-estimating-pi-using-monte-carlo-methods","text":"","title":"Problem 2 - Estimating Pi using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One of the most elegant applications is estimating the value of \\(\\pi\\) through geometric probability. By randomly generating points and analyzing their positions relative to a geometric shape, we can approximate \\(\\pi\\) in an intuitive and visually engaging way. This problem connects fundamental concepts of probability , geometry , and numerical computation . It also provides a gateway to understand how randomness can be harnessed to solve complex problems in physics, finance, and computer science.","title":"\ud83d\udd37 Motivation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#task","text":"","title":"\ud83d\udd37 Task:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-pi-using-a-circle","text":"","title":"\ud83d\udd39 PART 1: Estimating \\(\\pi\\) Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"Explain how the ratio of points inside a circle to the total number of points in a square can be used to estimate \\(\\pi\\) . Derive the formula: [ \\pi \\approx 4 \\cdot \\left(\\frac{\\text{points inside circle}}{\\text{total points}}\\right) ] for a unit circle.","title":"1. Theoretical Foundation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"Generate random points in a 2D square bounding a unit circle. Count the number of points falling inside the circle. Estimate \\(\\pi\\) based on this ratio.","title":"2. Simulation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"Create a plot showing the randomly generated points. Distinguish between those inside and outside the circle.","title":"3. Visualization:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis","text":"Investigate how accuracy improves as the number of points increases. Discuss convergence rate and computational considerations.","title":"4. Analysis:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-pi-using-buffons-needle","text":"","title":"\ud83d\udd39 PART 2: Estimating \\(\\pi\\) Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"Describe Buffon\u2019s Needle problem: estimate \\(\\pi\\) based on the probability of a needle crossing parallel lines. Derive the formula: [ \\pi \\approx \\frac{2 \\cdot \\text{needle length} \\cdot \\text{number of throws}}{\\text{distance between lines} \\cdot \\text{number of crossings}} ]","title":"1. Theoretical Foundation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation_1","text":"Simulate the random dropping of a needle on a plane with parallel lines. Count how many times the needle crosses a line. Estimate \\(\\pi\\) using the formula.","title":"2. Simulation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization_1","text":"Create a graphical representation of the simulation. Show needle positions relative to the lines.","title":"3. Visualization:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis_1","text":"Explore how the number of drops affects accuracy. Compare convergence with the circle-based method.","title":"4. Analysis:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#deliverables","text":"A Markdown document with: Clear explanations of both methods Discussion of theoretical foundations and results Python scripts/notebooks: Code for circle-based Monte Carlo simulation Code for Buffon\u2019s Needle simulation Graphical outputs: Plots of random points (circle method) Visualizations of needle positions (Buffon\u2019s method) Analysis: Tables/graphs showing convergence vs iterations Comparison of both methods in terms of accuracy & efficiency","title":"\ud83d\udd37 Deliverables:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#hints-and-resources","text":"Use NumPy for random generation Use Matplotlib for visualizations Ensure uniform random point generation (for circle method) In Buffon\u2019s Needle: Pay attention to geometry: needle length vs distance between lines Start with small iteration counts, then increase for convergence","title":"\ud83d\udd37 Hints and Resources:"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 - Measuring Earth's Gravitational Acceleration with a Pendulum \ud83d\udd0d Motivation The acceleration \\( g \\) due to gravity is a fundamental constant that influences a wide range of physical phenomena. One classic method for determining \\( g \\) is through the oscillations of a simple pendulum, where the period depends on the local gravitational field. \ud83e\uddea Procedure 1. Materials: A string (~1\u20131.5 meters) A small weight (e.g., washer, keychain) Stopwatch (or phone timer) Ruler or measuring tape 2. Setup: Attach the weight and suspend the string. Measure pendulum length \\( L \\) from suspension point to center of mass. Estimate uncertainty in \\( L \\) as: \\[ \\Delta L = \\frac{\\text{Ruler Resolution}}{2} \\] 3. Data Collection: Pull pendulum to <15\u00b0 and release. Measure \\( T_{10} \\) for 10 full oscillations, 10 times. Compute: Mean time: \\( \\overline{T_{10}} \\) Standard deviation: \\( \\sigma_T \\) Uncertainty: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}}, \\quad n = 10 \\] \ud83e\uddee Calculations 1. Calculate the period: \\[ T = \\frac{\\overline{T_{10}}}{10}, \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} \\] 2. Determine g: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] 3. Propagate uncertainties: \\[ \\Delta g = g \\sqrt{ \\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\frac{\\Delta T}{T}\\right)^2 } \\] \ud83d\udcca Analysis Compare measured \\( g \\) with standard \\( 9.81 \\, m/s^2 \\) Discuss: Measurement resolution's effect on \\( \\Delta L \\) Timing variability and \\( \\Delta T \\) Assumptions & limitations \u2705 Deliverables Tabulated: \\( L \\) , \\( \\Delta L \\) , \\( T_{10} \\) , \\( \\overline{T_{10}} \\) , \\( \\sigma_T \\) , \\( \\Delta T \\) , \\( g \\) , \\( \\Delta g \\) Python script (.py) used for calculations and visualizations \u2705 Results and Analysis Measured Values: Quantity Symbol Value Pendulum Length \\( L \\) 1.00 m Uncertainty in \\( L \\) \\( \\Delta L \\) 0.005 m Mean Time for 10 Oscillations \\( \\overline{T}_{10} \\) 20.250 s Std Dev of \\( T_{10} \\) \\( \\sigma_T \\) 0.085 s Uncertainty in \\( T_{10} \\) \\( \\Delta T_{10} \\) 0.027 s Period \\( T \\) 2.025 s Uncertainty in \\( T \\) \\( \\Delta T \\) 0.003 s Calculated \\( g \\) \\( g \\) 9.63 m/s\u00b2 Uncertainty in \\( g \\) \\( \\Delta g \\) 0.05 m/s\u00b2 \ud83d\udcac Discussion Comparison with standard value: The calculated \\( g = 9.63 \\, \\text{m/s}^2 \\) is slightly lower than the accepted standard \\( 9.81 \\, \\text{m/s}^2 \\) , within experimental uncertainty. Effect of resolution \\( \\Delta L \\) : Small uncertainty in length slightly affects the precision but is relatively minimal. Timing variability \\( \\Delta T \\) : The most significant contributor to uncertainty arises from human reaction time during stopwatch usage. Experimental limitations: Manual timing, air resistance, and angle variations (<15\u00b0 assumed) may have introduced errors. \ud83d\udce6 Deliverables Summary \u2705 Python simulation in pendulum_measurement.py \u2705 Markdown documentation with formulas, procedure, and results \u2705 Quantitative uncertainty analysis and final discussion","title":"Problem 1 - Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1-measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Problem 1 - Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration \\( g \\) due to gravity is a fundamental constant that influences a wide range of physical phenomena. One classic method for determining \\( g \\) is through the oscillations of a simple pendulum, where the period depends on the local gravitational field.","title":"\ud83d\udd0d Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"\ud83e\uddea Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-materials","text":"A string (~1\u20131.5 meters) A small weight (e.g., washer, keychain) Stopwatch (or phone timer) Ruler or measuring tape","title":"1. Materials:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-setup","text":"Attach the weight and suspend the string. Measure pendulum length \\( L \\) from suspension point to center of mass. Estimate uncertainty in \\( L \\) as: \\[ \\Delta L = \\frac{\\text{Ruler Resolution}}{2} \\]","title":"2. Setup:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-data-collection","text":"Pull pendulum to <15\u00b0 and release. Measure \\( T_{10} \\) for 10 full oscillations, 10 times. Compute: Mean time: \\( \\overline{T_{10}} \\) Standard deviation: \\( \\sigma_T \\) Uncertainty: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}}, \\quad n = 10 \\]","title":"3. Data Collection:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"\ud83e\uddee Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-calculate-the-period","text":"\\[ T = \\frac{\\overline{T_{10}}}{10}, \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} \\]","title":"1. Calculate the period:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-determine-g","text":"\\[ g = \\frac{4\\pi^2 L}{T^2} \\]","title":"2. Determine g:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-propagate-uncertainties","text":"\\[ \\Delta g = g \\sqrt{ \\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\frac{\\Delta T}{T}\\right)^2 } \\]","title":"3. Propagate uncertainties:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"Compare measured \\( g \\) with standard \\( 9.81 \\, m/s^2 \\) Discuss: Measurement resolution's effect on \\( \\Delta L \\) Timing variability and \\( \\Delta T \\) Assumptions & limitations","title":"\ud83d\udcca Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#deliverables","text":"Tabulated: \\( L \\) , \\( \\Delta L \\) , \\( T_{10} \\) , \\( \\overline{T_{10}} \\) , \\( \\sigma_T \\) , \\( \\Delta T \\) , \\( g \\) , \\( \\Delta g \\) Python script (.py) used for calculations and visualizations","title":"\u2705 Deliverables"},{"location":"1%20Physics/7%20Measurements/Problem_1/#results-and-analysis","text":"Measured Values: Quantity Symbol Value Pendulum Length \\( L \\) 1.00 m Uncertainty in \\( L \\) \\( \\Delta L \\) 0.005 m Mean Time for 10 Oscillations \\( \\overline{T}_{10} \\) 20.250 s Std Dev of \\( T_{10} \\) \\( \\sigma_T \\) 0.085 s Uncertainty in \\( T_{10} \\) \\( \\Delta T_{10} \\) 0.027 s Period \\( T \\) 2.025 s Uncertainty in \\( T \\) \\( \\Delta T \\) 0.003 s Calculated \\( g \\) \\( g \\) 9.63 m/s\u00b2 Uncertainty in \\( g \\) \\( \\Delta g \\) 0.05 m/s\u00b2","title":"\u2705 Results and Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion","text":"Comparison with standard value: The calculated \\( g = 9.63 \\, \\text{m/s}^2 \\) is slightly lower than the accepted standard \\( 9.81 \\, \\text{m/s}^2 \\) , within experimental uncertainty. Effect of resolution \\( \\Delta L \\) : Small uncertainty in length slightly affects the precision but is relatively minimal. Timing variability \\( \\Delta T \\) : The most significant contributor to uncertainty arises from human reaction time during stopwatch usage. Experimental limitations: Manual timing, air resistance, and angle variations (<15\u00b0 assumed) may have introduced errors.","title":"\ud83d\udcac Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#deliverables-summary","text":"\u2705 Python simulation in pendulum_measurement.py \u2705 Markdown documentation with formulas, procedure, and results \u2705 Quantitative uncertainty analysis and final discussion","title":"\ud83d\udce6 Deliverables Summary"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}